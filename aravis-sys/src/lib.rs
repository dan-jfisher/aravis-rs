// This file was generated by gir (https://github.com/gtk-rs/gir @ 2bb6380)
// from gir-files (https://github.com/gtk-rs/gir-files @ f7e3c51)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal)]

extern crate libc;
extern crate glib_sys as glib;
extern crate gio_sys as gio;
extern crate gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type ArvPixelFormat = u32;

// Enums
pub type ArvAcquisitionMode = c_int;
pub const ARV_ACQUISITION_MODE_CONTINUOUS: ArvAcquisitionMode = 0;
pub const ARV_ACQUISITION_MODE_SINGLE_FRAME: ArvAcquisitionMode = 1;
pub const ARV_ACQUISITION_MODE_MULTI_FRAME: ArvAcquisitionMode = 2;

pub type ArvAuto = c_int;
pub const ARV_AUTO_OFF: ArvAuto = 0;
pub const ARV_AUTO_ONCE: ArvAuto = 1;
pub const ARV_AUTO_CONTINUOUS: ArvAuto = 2;

pub type ArvBufferPayloadType = c_int;
pub const ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN: ArvBufferPayloadType = -1;
pub const ARV_BUFFER_PAYLOAD_TYPE_IMAGE: ArvBufferPayloadType = 1;
pub const ARV_BUFFER_PAYLOAD_TYPE_RAWDATA: ArvBufferPayloadType = 2;
pub const ARV_BUFFER_PAYLOAD_TYPE_FILE: ArvBufferPayloadType = 3;
pub const ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA: ArvBufferPayloadType = 4;
pub const ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA: ArvBufferPayloadType = 5;
pub const ARV_BUFFER_PAYLOAD_TYPE_JPEG: ArvBufferPayloadType = 6;
pub const ARV_BUFFER_PAYLOAD_TYPE_JPEG2000: ArvBufferPayloadType = 7;
pub const ARV_BUFFER_PAYLOAD_TYPE_H264: ArvBufferPayloadType = 8;
pub const ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE: ArvBufferPayloadType = 9;
pub const ARV_BUFFER_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK: ArvBufferPayloadType = 16385;

pub type ArvBufferStatus = c_int;
pub const ARV_BUFFER_STATUS_UNKNOWN: ArvBufferStatus = -1;
pub const ARV_BUFFER_STATUS_SUCCESS: ArvBufferStatus = 0;
pub const ARV_BUFFER_STATUS_CLEARED: ArvBufferStatus = 1;
pub const ARV_BUFFER_STATUS_TIMEOUT: ArvBufferStatus = 2;
pub const ARV_BUFFER_STATUS_MISSING_PACKETS: ArvBufferStatus = 3;
pub const ARV_BUFFER_STATUS_WRONG_PACKET_ID: ArvBufferStatus = 4;
pub const ARV_BUFFER_STATUS_SIZE_MISMATCH: ArvBufferStatus = 5;
pub const ARV_BUFFER_STATUS_FILLING: ArvBufferStatus = 6;
pub const ARV_BUFFER_STATUS_ABORTED: ArvBufferStatus = 7;

pub type ArvChunkParserError = c_int;
pub const ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE: ArvChunkParserError = 0;
pub const ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND: ArvChunkParserError = 1;
pub const ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND: ArvChunkParserError = 2;

pub type ArvDebugLevel = c_int;
pub const ARV_DEBUG_LEVEL_NONE: ArvDebugLevel = 0;
pub const ARV_DEBUG_LEVEL_WARNING: ArvDebugLevel = 1;
pub const ARV_DEBUG_LEVEL_DEBUG: ArvDebugLevel = 2;
pub const ARV_DEBUG_LEVEL_LOG: ArvDebugLevel = 3;
pub const ARV_DEBUG_LEVEL_COUNT: ArvDebugLevel = 4;

pub type ArvDomNodeType = c_int;
pub const ARV_DOM_NODE_TYPE_ELEMENT_NODE: ArvDomNodeType = 1;
pub const ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE: ArvDomNodeType = 2;
pub const ARV_DOM_NODE_TYPE_TEXT_NODE: ArvDomNodeType = 3;
pub const ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE: ArvDomNodeType = 4;
pub const ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE: ArvDomNodeType = 5;
pub const ARV_DOM_NODE_TYPE_ENTITY_NODE: ArvDomNodeType = 6;
pub const ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE: ArvDomNodeType = 7;
pub const ARV_DOM_NODE_TYPE_COMMENT_NODE: ArvDomNodeType = 8;
pub const ARV_DOM_NODE_TYPE_DOCUMENT_NODE: ArvDomNodeType = 9;
pub const ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE: ArvDomNodeType = 10;
pub const ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE: ArvDomNodeType = 11;
pub const ARV_DOM_NODE_TYPE_NOTATION_NODE: ArvDomNodeType = 12;

pub type ArvGcAccessMode = c_int;
pub const ARV_GC_ACCESS_MODE_UNDEFINED: ArvGcAccessMode = -1;
pub const ARV_GC_ACCESS_MODE_RO: ArvGcAccessMode = 0;
pub const ARV_GC_ACCESS_MODE_WO: ArvGcAccessMode = 1;
pub const ARV_GC_ACCESS_MODE_RW: ArvGcAccessMode = 2;

pub type ArvGcCachable = c_int;
pub const ARV_GC_CACHABLE_UNDEFINED: ArvGcCachable = -1;
pub const ARV_GC_CACHABLE_NO_CACHE: ArvGcCachable = 0;
pub const ARV_GC_CACHABLE_WRITE_THROUGH: ArvGcCachable = 1;
pub const ARV_GC_CACHABLE_WRITE_AROUND: ArvGcCachable = 2;

pub type ArvGcError = c_int;
pub const ARV_GC_ERROR_PROPERTY_NOT_DEFINED: ArvGcError = 0;
pub const ARV_GC_ERROR_PVALUE_NOT_DEFINED: ArvGcError = 1;
pub const ARV_GC_ERROR_INVALID_PVALUE: ArvGcError = 2;
pub const ARV_GC_ERROR_EMPTY_ENUMERATION: ArvGcError = 3;
pub const ARV_GC_ERROR_OUT_OF_RANGE: ArvGcError = 4;
pub const ARV_GC_ERROR_NO_DEVICE_SET: ArvGcError = 5;
pub const ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION: ArvGcError = 6;
pub const ARV_GC_ERROR_NODE_NOT_FOUND: ArvGcError = 7;
pub const ARV_GC_ERROR_INVALID_LENGTH: ArvGcError = 8;
pub const ARV_GC_ERROR_READ_ONLY: ArvGcError = 9;
pub const ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED: ArvGcError = 10;
pub const ARV_GC_ERROR_GET_AS_STRING_UNDEFINED: ArvGcError = 11;

pub type ArvGcIsLinear = c_int;
pub const ARV_GC_IS_LINEAR_UNDEFINED: ArvGcIsLinear = -1;
pub const ARV_GC_IS_LINEAR_NO: ArvGcIsLinear = 0;
pub const ARV_GC_IS_LINEAR_YES: ArvGcIsLinear = 1;

pub type ArvGcNameSpace = c_int;
pub const ARV_GC_NAME_SPACE_UNDEFINED: ArvGcNameSpace = -1;
pub const ARV_GC_NAME_SPACE_STANDARD: ArvGcNameSpace = 0;
pub const ARV_GC_NAME_SPACE_CUSTOM: ArvGcNameSpace = 1;

pub type ArvGcPropertyNodeType = c_int;
pub const ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN: ArvGcPropertyNodeType = 0;
pub const ARV_GC_PROPERTY_NODE_TYPE_VALUE: ArvGcPropertyNodeType = 1;
pub const ARV_GC_PROPERTY_NODE_TYPE_ADDRESS: ArvGcPropertyNodeType = 2;
pub const ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION: ArvGcPropertyNodeType = 3;
pub const ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP: ArvGcPropertyNodeType = 4;
pub const ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME: ArvGcPropertyNodeType = 5;
pub const ARV_GC_PROPERTY_NODE_TYPE_MINIMUM: ArvGcPropertyNodeType = 6;
pub const ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM: ArvGcPropertyNodeType = 7;
pub const ARV_GC_PROPERTY_NODE_TYPE_SLOPE: ArvGcPropertyNodeType = 8;
pub const ARV_GC_PROPERTY_NODE_TYPE_INCREMENT: ArvGcPropertyNodeType = 9;
pub const ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR: ArvGcPropertyNodeType = 10;
pub const ARV_GC_PROPERTY_NODE_TYPE_UNIT: ArvGcPropertyNodeType = 11;
pub const ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE: ArvGcPropertyNodeType = 12;
pub const ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE: ArvGcPropertyNodeType = 13;
pub const ARV_GC_PROPERTY_NODE_TYPE_LENGTH: ArvGcPropertyNodeType = 14;
pub const ARV_GC_PROPERTY_NODE_TYPE_FORMULA: ArvGcPropertyNodeType = 15;
pub const ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO: ArvGcPropertyNodeType = 16;
pub const ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM: ArvGcPropertyNodeType = 17;
pub const ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION: ArvGcPropertyNodeType = 18;
pub const ARV_GC_PROPERTY_NODE_TYPE_CONSTANT: ArvGcPropertyNodeType = 19;
pub const ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE: ArvGcPropertyNodeType = 20;
pub const ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE: ArvGcPropertyNodeType = 21;
pub const ARV_GC_PROPERTY_NODE_TYPE_CACHABLE: ArvGcPropertyNodeType = 22;
pub const ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME: ArvGcPropertyNodeType = 23;
pub const ARV_GC_PROPERTY_NODE_TYPE_ENDIANESS: ArvGcPropertyNodeType = 24;
pub const ARV_GC_PROPERTY_NODE_TYPE_SIGN: ArvGcPropertyNodeType = 25;
pub const ARV_GC_PROPERTY_NODE_TYPE_LSB: ArvGcPropertyNodeType = 26;
pub const ARV_GC_PROPERTY_NODE_TYPE_MSB: ArvGcPropertyNodeType = 27;
pub const ARV_GC_PROPERTY_NODE_TYPE_BIT: ArvGcPropertyNodeType = 28;
pub const ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE: ArvGcPropertyNodeType = 29;
pub const ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID: ArvGcPropertyNodeType = 30;
pub const ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID: ArvGcPropertyNodeType = 31;
pub const ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED: ArvGcPropertyNodeType = 32;
pub const ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT: ArvGcPropertyNodeType = 33;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW: ArvGcPropertyNodeType = 1000;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE: ArvGcPropertyNodeType = 1001;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VALUE: ArvGcPropertyNodeType = 1002;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS: ArvGcPropertyNodeType = 1003;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED: ArvGcPropertyNodeType = 1004;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED: ArvGcPropertyNodeType = 1005;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE: ArvGcPropertyNodeType = 1006;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED: ArvGcPropertyNodeType = 1007;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM: ArvGcPropertyNodeType = 1008;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM: ArvGcPropertyNodeType = 1009;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT: ArvGcPropertyNodeType = 1010;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_INDEX: ArvGcPropertyNodeType = 1011;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH: ArvGcPropertyNodeType = 1012;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_PORT: ArvGcPropertyNodeType = 1013;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE: ArvGcPropertyNodeType = 1014;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR: ArvGcPropertyNodeType = 1015;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE: ArvGcPropertyNodeType = 1016;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED: ArvGcPropertyNodeType = 1017;
pub const ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT: ArvGcPropertyNodeType = 1018;

pub type ArvGcSignedness = c_int;
pub const ARV_GC_SIGNEDNESS_UNDEFINED: ArvGcSignedness = -1;
pub const ARV_GC_SIGNEDNESS_SIGNED: ArvGcSignedness = 0;
pub const ARV_GC_SIGNEDNESS_UNSIGNED: ArvGcSignedness = 1;

pub type ArvGvStreamOption = c_int;
pub const ARV_GV_STREAM_OPTION_NONE: ArvGvStreamOption = 0;
pub const ARV_GV_STREAM_OPTION_PACKET_SOCKET_DISABLED: ArvGvStreamOption = 1;

pub type ArvGvStreamPacketResend = c_int;
pub const ARV_GV_STREAM_PACKET_RESEND_NEVER: ArvGvStreamPacketResend = 0;
pub const ARV_GV_STREAM_PACKET_RESEND_ALWAYS: ArvGvStreamPacketResend = 1;

pub type ArvGvStreamSocketBuffer = c_int;
pub const ARV_GV_STREAM_SOCKET_BUFFER_FIXED: ArvGvStreamSocketBuffer = 0;
pub const ARV_GV_STREAM_SOCKET_BUFFER_AUTO: ArvGvStreamSocketBuffer = 1;

pub type ArvRegisterCachePolicy = c_int;
pub const ARV_REGISTER_CACHE_POLICY_DISABLE: ArvRegisterCachePolicy = 0;
pub const ARV_REGISTER_CACHE_POLICY_ENABLE: ArvRegisterCachePolicy = 1;
pub const ARV_REGISTER_CACHE_POLICY_DEBUG: ArvRegisterCachePolicy = 2;

pub type ArvStatus = c_int;
pub const ARV_STATUS_UNKNOWN: ArvStatus = -1;
pub const ARV_STATUS_SUCCESS: ArvStatus = 0;
pub const ARV_STATUS_TIMEOUT: ArvStatus = 1;
pub const ARV_STATUS_WRITE_ERROR: ArvStatus = 2;
pub const ARV_STATUS_TRANSFER_ERROR: ArvStatus = 3;
pub const ARV_STATUS_PROTOCOL_ERROR: ArvStatus = 4;
pub const ARV_STATUS_NOT_CONNECTED: ArvStatus = 5;

pub type ArvStreamCallbackType = c_int;
pub const ARV_STREAM_CALLBACK_TYPE_INIT: ArvStreamCallbackType = 0;
pub const ARV_STREAM_CALLBACK_TYPE_EXIT: ArvStreamCallbackType = 1;
pub const ARV_STREAM_CALLBACK_TYPE_START_BUFFER: ArvStreamCallbackType = 2;
pub const ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE: ArvStreamCallbackType = 3;

pub type ArvXmlSchemaError = c_int;
pub const ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE: ArvXmlSchemaError = 0;

// Constants
pub const ARV_FAKE_CAMERA_ACQUISITION_FRAME_RATE_DEFAULT: c_double = 25.000000;
pub const ARV_FAKE_CAMERA_BINNING_HORIZONTAL_DEFAULT: c_int = 1;
pub const ARV_FAKE_CAMERA_BINNING_VERTICAL_DEFAULT: c_int = 1;
pub const ARV_FAKE_CAMERA_EXPOSURE_TIME_US_DEFAULT: c_double = 10000.000000;
pub const ARV_FAKE_CAMERA_HEIGHT_DEFAULT: c_int = 512;
pub const ARV_FAKE_CAMERA_MEMORY_SIZE: c_int = 65536;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION: c_int = 292;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION_FRAME_PERIOD_US: c_int = 312;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION_MODE: c_int = 300;
pub const ARV_FAKE_CAMERA_REGISTER_ACQUISITION_START_OFFSET: c_int = 32;
pub const ARV_FAKE_CAMERA_REGISTER_BINNING_HORIZONTAL: c_int = 264;
pub const ARV_FAKE_CAMERA_REGISTER_BINNING_VERTICAL: c_int = 268;
pub const ARV_FAKE_CAMERA_REGISTER_EXPOSURE_TIME_US: c_int = 288;
pub const ARV_FAKE_CAMERA_REGISTER_FRAME_START_OFFSET: c_int = 0;
pub const ARV_FAKE_CAMERA_REGISTER_GAIN_MODE: c_int = 276;
pub const ARV_FAKE_CAMERA_REGISTER_GAIN_RAW: c_int = 272;
pub const ARV_FAKE_CAMERA_REGISTER_HEIGHT: c_int = 260;
pub const ARV_FAKE_CAMERA_REGISTER_PIXEL_FORMAT: c_int = 296;
pub const ARV_FAKE_CAMERA_REGISTER_SENSOR_HEIGHT: c_int = 280;
pub const ARV_FAKE_CAMERA_REGISTER_SENSOR_WIDTH: c_int = 284;
pub const ARV_FAKE_CAMERA_REGISTER_TEST: c_int = 496;
pub const ARV_FAKE_CAMERA_REGISTER_TRIGGER_ACTIVATION: c_int = 776;
pub const ARV_FAKE_CAMERA_REGISTER_TRIGGER_MODE: c_int = 768;
pub const ARV_FAKE_CAMERA_REGISTER_TRIGGER_SOURCE: c_int = 772;
pub const ARV_FAKE_CAMERA_REGISTER_WIDTH: c_int = 256;
pub const ARV_FAKE_CAMERA_REGISTER_X_OFFSET: c_int = 304;
pub const ARV_FAKE_CAMERA_REGISTER_Y_OFFSET: c_int = 308;
pub const ARV_FAKE_CAMERA_SENSOR_HEIGHT: c_int = 2048;
pub const ARV_FAKE_CAMERA_SENSOR_WIDTH: c_int = 2048;
pub const ARV_FAKE_CAMERA_TEST_REGISTER_DEFAULT: c_int = 305419896;
pub const ARV_FAKE_CAMERA_WIDTH_DEFAULT: c_int = 512;
pub const ARV_GV_FAKE_CAMERA_DEFAULT_INTERFACE: *const c_char = b"lo\0" as *const u8 as *const c_char;
pub const ARV_GV_FAKE_CAMERA_DEFAULT_SERIAL_NUMBER: *const c_char = b"GV01\0" as *const u8 as *const c_char;
pub const ARV_PIXEL_FORMAT_BAYER_BG_10: ArvPixelFormat = 17825807;
pub const ARV_PIXEL_FORMAT_BAYER_BG_10P: ArvPixelFormat = 17432658;
pub const ARV_PIXEL_FORMAT_BAYER_BG_10_PACKED: ArvPixelFormat = 17563689;
pub const ARV_PIXEL_FORMAT_BAYER_BG_12: ArvPixelFormat = 17825811;
pub const ARV_PIXEL_FORMAT_BAYER_BG_12P: ArvPixelFormat = 17563731;
pub const ARV_PIXEL_FORMAT_BAYER_BG_12_PACKED: ArvPixelFormat = 17563693;
pub const ARV_PIXEL_FORMAT_BAYER_BG_16: ArvPixelFormat = 17825841;
pub const ARV_PIXEL_FORMAT_BAYER_BG_8: ArvPixelFormat = 17301515;
pub const ARV_PIXEL_FORMAT_BAYER_GB_10: ArvPixelFormat = 17825806;
pub const ARV_PIXEL_FORMAT_BAYER_GB_10P: ArvPixelFormat = 17432660;
pub const ARV_PIXEL_FORMAT_BAYER_GB_10_PACKED: ArvPixelFormat = 17563688;
pub const ARV_PIXEL_FORMAT_BAYER_GB_12: ArvPixelFormat = 17825810;
pub const ARV_PIXEL_FORMAT_BAYER_GB_12P: ArvPixelFormat = 17563733;
pub const ARV_PIXEL_FORMAT_BAYER_GB_12_PACKED: ArvPixelFormat = 17563692;
pub const ARV_PIXEL_FORMAT_BAYER_GB_16: ArvPixelFormat = 17825840;
pub const ARV_PIXEL_FORMAT_BAYER_GB_8: ArvPixelFormat = 17301514;
pub const ARV_PIXEL_FORMAT_BAYER_GR_10: ArvPixelFormat = 17825804;
pub const ARV_PIXEL_FORMAT_BAYER_GR_10P: ArvPixelFormat = 17432662;
pub const ARV_PIXEL_FORMAT_BAYER_GR_10_PACKED: ArvPixelFormat = 17563686;
pub const ARV_PIXEL_FORMAT_BAYER_GR_12: ArvPixelFormat = 17825808;
pub const ARV_PIXEL_FORMAT_BAYER_GR_12P: ArvPixelFormat = 17563735;
pub const ARV_PIXEL_FORMAT_BAYER_GR_12_PACKED: ArvPixelFormat = 17563690;
pub const ARV_PIXEL_FORMAT_BAYER_GR_16: ArvPixelFormat = 17825838;
pub const ARV_PIXEL_FORMAT_BAYER_GR_8: ArvPixelFormat = 17301512;
pub const ARV_PIXEL_FORMAT_BAYER_RG_10: ArvPixelFormat = 17825805;
pub const ARV_PIXEL_FORMAT_BAYER_RG_10P: ArvPixelFormat = 17432664;
pub const ARV_PIXEL_FORMAT_BAYER_RG_10_PACKED: ArvPixelFormat = 17563687;
pub const ARV_PIXEL_FORMAT_BAYER_RG_12: ArvPixelFormat = 17825809;
pub const ARV_PIXEL_FORMAT_BAYER_RG_12P: ArvPixelFormat = 17563737;
pub const ARV_PIXEL_FORMAT_BAYER_RG_12_PACKED: ArvPixelFormat = 17563691;
pub const ARV_PIXEL_FORMAT_BAYER_RG_16: ArvPixelFormat = 17825839;
pub const ARV_PIXEL_FORMAT_BAYER_RG_8: ArvPixelFormat = 17301513;
pub const ARV_PIXEL_FORMAT_BGRA_8_PACKED: ArvPixelFormat = 35651607;
pub const ARV_PIXEL_FORMAT_BGR_10_PACKED: ArvPixelFormat = 36700185;
pub const ARV_PIXEL_FORMAT_BGR_12_PACKED: ArvPixelFormat = 36700187;
pub const ARV_PIXEL_FORMAT_BGR_8_PACKED: ArvPixelFormat = 35127317;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_BG_12_PACKED: ArvPixelFormat = 2165047300;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_BG_16: ArvPixelFormat = 2165309449;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GB_12_PACKED: ArvPixelFormat = 2165047299;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GB_16: ArvPixelFormat = 2165309448;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GR_12_PACKED: ArvPixelFormat = 2165047297;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_GR_16: ArvPixelFormat = 2165309446;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_RG_12_PACKED: ArvPixelFormat = 2165047298;
pub const ARV_PIXEL_FORMAT_CUSTOM_BAYER_RG_16: ArvPixelFormat = 2165309447;
pub const ARV_PIXEL_FORMAT_CUSTOM_YUV_422_YUYV_PACKED: ArvPixelFormat = 2182086661;
pub const ARV_PIXEL_FORMAT_MONO_10: ArvPixelFormat = 17825795;
pub const ARV_PIXEL_FORMAT_MONO_10_PACKED: ArvPixelFormat = 17563652;
pub const ARV_PIXEL_FORMAT_MONO_12: ArvPixelFormat = 17825797;
pub const ARV_PIXEL_FORMAT_MONO_12_PACKED: ArvPixelFormat = 17563654;
pub const ARV_PIXEL_FORMAT_MONO_14: ArvPixelFormat = 17825829;
pub const ARV_PIXEL_FORMAT_MONO_16: ArvPixelFormat = 17825799;
pub const ARV_PIXEL_FORMAT_MONO_8: ArvPixelFormat = 17301505;
pub const ARV_PIXEL_FORMAT_MONO_8_SIGNED: ArvPixelFormat = 17301506;
pub const ARV_PIXEL_FORMAT_RGBA_8_PACKED: ArvPixelFormat = 35651606;
pub const ARV_PIXEL_FORMAT_RGB_10_PACKED: ArvPixelFormat = 36700184;
pub const ARV_PIXEL_FORMAT_RGB_10_PLANAR: ArvPixelFormat = 36700194;
pub const ARV_PIXEL_FORMAT_RGB_12_PACKED: ArvPixelFormat = 36700186;
pub const ARV_PIXEL_FORMAT_RGB_12_PLANAR: ArvPixelFormat = 36700195;
pub const ARV_PIXEL_FORMAT_RGB_16_PLANAR: ArvPixelFormat = 36700196;
pub const ARV_PIXEL_FORMAT_RGB_8_PACKED: ArvPixelFormat = 35127316;
pub const ARV_PIXEL_FORMAT_RGB_8_PLANAR: ArvPixelFormat = 35127329;
pub const ARV_PIXEL_FORMAT_YUV_411_PACKED: ArvPixelFormat = 34340894;
pub const ARV_PIXEL_FORMAT_YUV_422_PACKED: ArvPixelFormat = 34603039;
pub const ARV_PIXEL_FORMAT_YUV_422_YUYV_PACKED: ArvPixelFormat = 34603058;
pub const ARV_PIXEL_FORMAT_YUV_444_PACKED: ArvPixelFormat = 35127328;

// Callbacks
pub type ArvDomDocumentCreateFunction = Option<unsafe extern "C" fn() -> *mut ArvDomDocument>;
pub type ArvFakeCameraFillPattern = Option<unsafe extern "C" fn(*mut ArvBuffer, *mut c_void, u32, u32, ArvPixelFormat)>;
pub type ArvFrameCallback = Option<unsafe extern "C" fn(*mut ArvBuffer)>;
pub type ArvStreamCallback = Option<unsafe extern "C" fn(*mut c_void, ArvStreamCallbackType, *mut ArvBuffer)>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvBufferClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvBufferClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvCameraClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvCameraClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvCameraClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvChunkParserClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvChunkParserClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvChunkParserClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDebugCategory {
    pub name: *mut c_char,
    pub level: ArvDebugLevel,
}

impl ::std::fmt::Debug for ArvDebugCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDebugCategory @ {:?}", self as *const _))
         .field("name", &self.name)
         .field("level", &self.level)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDeviceClass {
    pub parent_class: gobject::GObjectClass,
    pub create_stream: Option<unsafe extern "C" fn(*mut ArvDevice, ArvStreamCallback, *mut c_void) -> *mut ArvStream>,
    pub get_genicam_xml: Option<unsafe extern "C" fn(*mut ArvDevice, *mut size_t) -> *const c_char>,
    pub get_genicam: Option<unsafe extern "C" fn(*mut ArvDevice) -> *mut ArvGc>,
    pub read_memory: Option<unsafe extern "C" fn(*mut ArvDevice, u64, u32, *mut c_void, *mut *mut glib::GError) -> gboolean>,
    pub write_memory: Option<unsafe extern "C" fn(*mut ArvDevice, u64, u32, *mut c_void, *mut *mut glib::GError) -> gboolean>,
    pub read_register: Option<unsafe extern "C" fn(*mut ArvDevice, u64, u32, *mut *mut glib::GError) -> gboolean>,
    pub write_register: Option<unsafe extern "C" fn(*mut ArvDevice, u64, u32, *mut *mut glib::GError) -> gboolean>,
    pub control_lost: Option<unsafe extern "C" fn(*mut ArvDevice)>,
}

impl ::std::fmt::Debug for ArvDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDeviceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("create_stream", &self.create_stream)
         .field("get_genicam_xml", &self.get_genicam_xml)
         .field("get_genicam", &self.get_genicam)
         .field("read_memory", &self.read_memory)
         .field("write_memory", &self.write_memory)
         .field("read_register", &self.read_register)
         .field("write_register", &self.write_register)
         .field("control_lost", &self.control_lost)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomCharacterDataClass {
    pub parent_class: ArvDomNodeClass,
}

impl ::std::fmt::Debug for ArvDomCharacterDataClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomCharacterDataClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocumentClass {
    pub parent_class: ArvDomNodeClass,
    pub get_document_element: Option<unsafe extern "C" fn(*mut ArvDomDocument) -> *mut ArvDomElement>,
    pub create_element: Option<unsafe extern "C" fn(*mut ArvDomDocument, *const c_char) -> *mut ArvDomElement>,
    pub create_text_node: Option<unsafe extern "C" fn(*mut ArvDomDocument, *const c_char) -> *mut ArvDomText>,
}

impl ::std::fmt::Debug for ArvDomDocumentClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomDocumentClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("get_document_element", &self.get_document_element)
         .field("create_element", &self.create_element)
         .field("create_text_node", &self.create_text_node)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocumentFragmentClass {
    pub parent_class: ArvDomNodeClass,
}

impl ::std::fmt::Debug for ArvDomDocumentFragmentClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomDocumentFragmentClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomElementClass {
    pub parent_class: ArvDomNodeClass,
    pub get_attribute: Option<unsafe extern "C" fn(*mut ArvDomElement, *const c_char) -> *const c_char>,
    pub set_attribute: Option<unsafe extern "C" fn(*mut ArvDomElement, *const c_char, *const c_char)>,
    pub get_serialized_attributes: Option<unsafe extern "C" fn(*mut ArvDomElement) -> *mut c_char>,
}

impl ::std::fmt::Debug for ArvDomElementClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomElementClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("get_attribute", &self.get_attribute)
         .field("set_attribute", &self.set_attribute)
         .field("get_serialized_attributes", &self.get_serialized_attributes)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNamedNodeMapClass {
    pub parent_class: gobject::GObjectClass,
    pub get: Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, *const c_char) -> *mut ArvDomNode>,
    pub set: Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, *mut ArvDomNode) -> *mut ArvDomNode>,
    pub remove: Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, *const c_char) -> *mut ArvDomNode>,
    pub get_item: Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap, c_uint) -> *mut ArvDomNode>,
    pub get_length: Option<unsafe extern "C" fn(*mut ArvDomNamedNodeMap) -> c_uint>,
}

impl ::std::fmt::Debug for ArvDomNamedNodeMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomNamedNodeMapClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("get", &self.get)
         .field("set", &self.set)
         .field("remove", &self.remove)
         .field("get_item", &self.get_item)
         .field("get_length", &self.get_length)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNodeClass {
    pub parent_class: gobject::GObjectClass,
    pub get_node_name: Option<unsafe extern "C" fn(*mut ArvDomNode) -> *const c_char>,
    pub get_node_value: Option<unsafe extern "C" fn(*mut ArvDomNode) -> *const c_char>,
    pub set_node_value: Option<unsafe extern "C" fn(*mut ArvDomNode, *const c_char)>,
    pub get_node_type: Option<unsafe extern "C" fn(*mut ArvDomNode) -> ArvDomNodeType>,
    pub can_append_child: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode) -> gboolean>,
    pub post_new_child: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode)>,
    pub pre_remove_child: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode)>,
    pub changed: Option<unsafe extern "C" fn(*mut ArvDomNode)>,
    pub child_changed: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut ArvDomNode) -> gboolean>,
    pub write_to_stream: Option<unsafe extern "C" fn(*mut ArvDomNode, *mut gio::GOutputStream, *mut *mut glib::GError)>,
}

impl ::std::fmt::Debug for ArvDomNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("get_node_name", &self.get_node_name)
         .field("get_node_value", &self.get_node_value)
         .field("set_node_value", &self.set_node_value)
         .field("get_node_type", &self.get_node_type)
         .field("can_append_child", &self.can_append_child)
         .field("post_new_child", &self.post_new_child)
         .field("pre_remove_child", &self.pre_remove_child)
         .field("changed", &self.changed)
         .field("child_changed", &self.child_changed)
         .field("write_to_stream", &self.write_to_stream)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNodeListClass {
    pub parent_class: gobject::GObjectClass,
    pub get_item: Option<unsafe extern "C" fn(*mut ArvDomNodeList, c_uint) -> *mut ArvDomNode>,
    pub get_length: Option<unsafe extern "C" fn(*mut ArvDomNodeList) -> c_uint>,
}

impl ::std::fmt::Debug for ArvDomNodeListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomNodeListClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("get_item", &self.get_item)
         .field("get_length", &self.get_length)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomTextClass {
    pub parent_class: ArvDomCharacterDataClass,
}

impl ::std::fmt::Debug for ArvDomTextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomTextClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvEvaluatorClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvEvaluatorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvEvaluatorClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeCameraClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvFakeCameraClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeCameraClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeDeviceClass {
    pub parent_class: ArvDeviceClass,
}

impl ::std::fmt::Debug for ArvFakeDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeDeviceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeInterfaceClass {
    pub parent_class: ArvInterfaceClass,
}

impl ::std::fmt::Debug for ArvFakeInterfaceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeInterfaceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvFakeStreamClass {
    pub parent_class: ArvStreamClass,
}

impl ::std::fmt::Debug for ArvFakeStreamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeStreamClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcBooleanClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcBooleanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcBooleanClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcCategoryClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcCategoryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcCategoryClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcClass {
    pub parent_class: ArvDomDocumentClass,
}

impl ::std::fmt::Debug for ArvGcClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcCommandClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcCommandClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcCommandClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcConverterClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcConverterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcConverterClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcConverterNodeClass {
    pub parent_class: ArvGcConverterClass,
}

impl ::std::fmt::Debug for ArvGcConverterNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcConverterNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcEnumEntryClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcEnumEntryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcEnumEntryClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcEnumerationClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcEnumerationClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcEnumerationClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFeatureNodeClass {
    pub parent_class: ArvGcNodeClass,
}

impl ::std::fmt::Debug for ArvGcFeatureNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcFeatureNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatInterface {
    pub parent: gobject::GTypeInterface,
    pub get_value: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
    pub set_value: Option<unsafe extern "C" fn(*mut ArvGcFloat, c_double, *mut *mut glib::GError)>,
    pub get_min: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
    pub get_max: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
    pub get_inc: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> c_double>,
    pub get_unit: Option<unsafe extern "C" fn(*mut ArvGcFloat, *mut *mut glib::GError) -> *const c_char>,
    pub impose_min: Option<unsafe extern "C" fn(*mut ArvGcFloat, c_double, *mut *mut glib::GError)>,
    pub impose_max: Option<unsafe extern "C" fn(*mut ArvGcFloat, c_double, *mut *mut glib::GError)>,
}

impl ::std::fmt::Debug for ArvGcFloatInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcFloatInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_value", &self.get_value)
         .field("set_value", &self.set_value)
         .field("get_min", &self.get_min)
         .field("get_max", &self.get_max)
         .field("get_inc", &self.get_inc)
         .field("get_unit", &self.get_unit)
         .field("impose_min", &self.impose_min)
         .field("impose_max", &self.impose_max)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatNodeClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcFloatNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcFloatNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatRegNodeClass {
    pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcFloatRegNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcFloatRegNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcGroupNodeClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcGroupNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcGroupNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIndexNodeClass {
    pub parent_class: ArvGcPropertyNodeClass,
}

impl ::std::fmt::Debug for ArvGcIndexNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIndexNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntConverterNodeClass {
    pub parent_class: ArvGcConverterClass,
}

impl ::std::fmt::Debug for ArvGcIntConverterNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntConverterNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntRegNodeClass {
    pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcIntRegNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntRegNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntSwissKnifeNodeClass {
    pub parent_class: ArvGcSwissKnifeClass,
}

impl ::std::fmt::Debug for ArvGcIntSwissKnifeNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntSwissKnifeNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntegerInterface {
    pub parent: gobject::GTypeInterface,
    pub get_value: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
    pub set_value: Option<unsafe extern "C" fn(*mut ArvGcInteger, i64, *mut *mut glib::GError)>,
    pub get_min: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
    pub get_max: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
    pub get_inc: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> i64>,
    pub get_unit: Option<unsafe extern "C" fn(*mut ArvGcInteger, *mut *mut glib::GError) -> *const c_char>,
    pub impose_min: Option<unsafe extern "C" fn(*mut ArvGcInteger, i64, *mut *mut glib::GError)>,
    pub impose_max: Option<unsafe extern "C" fn(*mut ArvGcInteger, i64, *mut *mut glib::GError)>,
}

impl ::std::fmt::Debug for ArvGcIntegerInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntegerInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_value", &self.get_value)
         .field("set_value", &self.set_value)
         .field("get_min", &self.get_min)
         .field("get_max", &self.get_max)
         .field("get_inc", &self.get_inc)
         .field("get_unit", &self.get_unit)
         .field("impose_min", &self.impose_min)
         .field("impose_max", &self.impose_max)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntegerNodeClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcIntegerNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntegerNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcInvalidatorNodeClass {
    pub parent_class: ArvGcPropertyNodeClass,
}

impl ::std::fmt::Debug for ArvGcInvalidatorNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcInvalidatorNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcMaskedIntRegNodeClass {
    pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcMaskedIntRegNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcMaskedIntRegNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcNodeClass {
    pub parent_class: ArvDomElementClass,
}

impl ::std::fmt::Debug for ArvGcNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcPortClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcPortClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcPortClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcPropertyNodeClass {
    pub parent_class: ArvGcNodeClass,
}

impl ::std::fmt::Debug for ArvGcPropertyNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcPropertyNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterDescriptionNodeClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcRegisterDescriptionNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcRegisterDescriptionNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterInterface {
    pub parent: gobject::GTypeInterface,
    pub get: Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut c_void, u64, *mut *mut glib::GError)>,
    pub set: Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut c_void, u64, *mut *mut glib::GError)>,
    pub get_address: Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut *mut glib::GError) -> u64>,
    pub get_length: Option<unsafe extern "C" fn(*mut ArvGcRegister, *mut *mut glib::GError) -> u64>,
}

impl ::std::fmt::Debug for ArvGcRegisterInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcRegisterInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get", &self.get)
         .field("set", &self.set)
         .field("get_address", &self.get_address)
         .field("get_length", &self.get_length)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterNodeClass {
    pub parent_class: ArvGcFeatureNodeClass,
    pub default_cachable: ArvGcCachable,
}

impl ::std::fmt::Debug for ArvGcRegisterNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcRegisterNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("default_cachable", &self.default_cachable)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSelectorInterface {
    pub parent: gobject::GTypeInterface,
    pub get_selected_features: Option<unsafe extern "C" fn(*mut ArvGcSelector) -> *const glib::GSList>,
}

impl ::std::fmt::Debug for ArvGcSelectorInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcSelectorInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_selected_features", &self.get_selected_features)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStringInterface {
    pub parent: gobject::GTypeInterface,
    pub get_value: Option<unsafe extern "C" fn(*mut ArvGcString, *mut *mut glib::GError) -> *const c_char>,
    pub set_value: Option<unsafe extern "C" fn(*mut ArvGcString, *const c_char, *mut *mut glib::GError)>,
    pub get_max_length: Option<unsafe extern "C" fn(*mut ArvGcString, *mut *mut glib::GError) -> i64>,
}

impl ::std::fmt::Debug for ArvGcStringInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcStringInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_value", &self.get_value)
         .field("set_value", &self.set_value)
         .field("get_max_length", &self.get_max_length)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStringRegNodeClass {
    pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcStringRegNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcStringRegNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStructEntryNodeClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcStructEntryNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcStructEntryNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStructRegNodeClass {
    pub parent_class: ArvGcRegisterNodeClass,
}

impl ::std::fmt::Debug for ArvGcStructRegNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcStructRegNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnifeClass {
    pub parent_class: ArvGcFeatureNodeClass,
}

impl ::std::fmt::Debug for ArvGcSwissKnifeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcSwissKnifeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnifeNodeClass {
    pub parent_class: ArvGcSwissKnifeClass,
}

impl ::std::fmt::Debug for ArvGcSwissKnifeNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcSwissKnifeNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcValueIndexedNodeClass {
    pub parent_class: ArvGcPropertyNodeClass,
}

impl ::std::fmt::Debug for ArvGcValueIndexedNodeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcValueIndexedNodeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvDeviceClass {
    pub parent_class: ArvDeviceClass,
}

impl ::std::fmt::Debug for ArvGvDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvDeviceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvFakeCameraClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvGvFakeCameraClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvFakeCameraClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvInterfaceClass {
    pub parent_class: ArvInterfaceClass,
}

impl ::std::fmt::Debug for ArvGvInterfaceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvInterfaceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGvStreamClass {
    pub parent_class: ArvStreamClass,
}

impl ::std::fmt::Debug for ArvGvStreamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvStreamClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvInterfaceClass {
    pub parent_class: gobject::GObjectClass,
    pub update_device_list: Option<unsafe extern "C" fn(*mut ArvInterface, *mut glib::GArray)>,
    pub open_device: Option<unsafe extern "C" fn(*mut ArvInterface, *const c_char) -> *mut ArvDevice>,
    pub protocol: *const c_char,
}

impl ::std::fmt::Debug for ArvInterfaceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvInterfaceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("update_device_list", &self.update_device_list)
         .field("open_device", &self.open_device)
         .field("protocol", &self.protocol)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub start_thread: Option<unsafe extern "C" fn(*mut ArvStream)>,
    pub stop_thread: Option<unsafe extern "C" fn(*mut ArvStream)>,
    pub get_statistics: Option<unsafe extern "C" fn(*mut ArvStream, *mut u64, *mut u64, *mut u64)>,
    pub new_buffer: Option<unsafe extern "C" fn(*mut ArvStream)>,
}

impl ::std::fmt::Debug for ArvStreamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvStreamClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("start_thread", &self.start_thread)
         .field("stop_thread", &self.stop_thread)
         .field("get_statistics", &self.get_statistics)
         .field("new_buffer", &self.new_buffer)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvUvDeviceClass {
    pub parent_class: ArvDeviceClass,
}

impl ::std::fmt::Debug for ArvUvDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvUvDeviceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvUvInterfaceClass {
    pub parent_class: ArvInterfaceClass,
}

impl ::std::fmt::Debug for ArvUvInterfaceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvUvInterfaceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvUvStreamClass {
    pub parent_class: ArvStreamClass,
}

impl ::std::fmt::Debug for ArvUvStreamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvUvStreamClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvXmlSchemaClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ArvXmlSchemaClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvXmlSchemaClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _ArvZip(c_void);

pub type ArvZip = *mut _ArvZip;

#[repr(C)]
pub struct _ArvZipFile(c_void);

pub type ArvZipFile = *mut _ArvZipFile;

// Classes
#[repr(C)]
pub struct ArvBuffer(c_void);

impl ::std::fmt::Debug for ArvBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvBuffer @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvCamera {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvCamera {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvCamera @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvChunkParser(c_void);

impl ::std::fmt::Debug for ArvChunkParser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvChunkParser @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDevice {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDevice @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomCharacterData {
    pub node: ArvDomNode,
    pub data: *mut c_char,
}

impl ::std::fmt::Debug for ArvDomCharacterData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomCharacterData @ {:?}", self as *const _))
         .field("node", &self.node)
         .field("data", &self.data)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocument {
    pub node: ArvDomNode,
    pub url: *mut c_char,
}

impl ::std::fmt::Debug for ArvDomDocument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomDocument @ {:?}", self as *const _))
         .field("node", &self.node)
         .field("url", &self.url)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomDocumentFragment {
    pub node: ArvDomNode,
}

impl ::std::fmt::Debug for ArvDomDocumentFragment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomDocumentFragment @ {:?}", self as *const _))
         .field("node", &self.node)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomElement {
    pub node: ArvDomNode,
}

impl ::std::fmt::Debug for ArvDomElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomElement @ {:?}", self as *const _))
         .field("node", &self.node)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNamedNodeMap {
    pub object: gobject::GObject,
}

impl ::std::fmt::Debug for ArvDomNamedNodeMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomNamedNodeMap @ {:?}", self as *const _))
         .field("object", &self.object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNode {
    pub object: gobject::GObject,
    pub next_sibling: *mut ArvDomNode,
    pub previous_sibling: *mut ArvDomNode,
    pub parent_node: *mut ArvDomNode,
    pub first_child: *mut ArvDomNode,
    pub last_child: *mut ArvDomNode,
}

impl ::std::fmt::Debug for ArvDomNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomNode @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("next_sibling", &self.next_sibling)
         .field("previous_sibling", &self.previous_sibling)
         .field("parent_node", &self.parent_node)
         .field("first_child", &self.first_child)
         .field("last_child", &self.last_child)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomNodeList {
    pub object: gobject::GObject,
}

impl ::std::fmt::Debug for ArvDomNodeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomNodeList @ {:?}", self as *const _))
         .field("object", &self.object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvDomText {
    pub character_data: ArvDomCharacterData,
}

impl ::std::fmt::Debug for ArvDomText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvDomText @ {:?}", self as *const _))
         .field("character_data", &self.character_data)
         .finish()
    }
}

#[repr(C)]
pub struct ArvEvaluator(c_void);

impl ::std::fmt::Debug for ArvEvaluator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvEvaluator @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvFakeCamera(c_void);

impl ::std::fmt::Debug for ArvFakeCamera {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeCamera @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvFakeDevice(c_void);

impl ::std::fmt::Debug for ArvFakeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeDevice @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvFakeInterface(c_void);

impl ::std::fmt::Debug for ArvFakeInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvFakeStream(c_void);

impl ::std::fmt::Debug for ArvFakeStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvFakeStream @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGc(c_void);

impl ::std::fmt::Debug for ArvGc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGc @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcBoolean(c_void);

impl ::std::fmt::Debug for ArvGcBoolean {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcBoolean @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcCategory(c_void);

impl ::std::fmt::Debug for ArvGcCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcCategory @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcCommand(c_void);

impl ::std::fmt::Debug for ArvGcCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcCommand @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcConverter {
    pub parent_instance: ArvGcFeatureNode,
}

impl ::std::fmt::Debug for ArvGcConverter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcConverter @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcConverterNode(c_void);

impl ::std::fmt::Debug for ArvGcConverterNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcConverterNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcEnumEntry(c_void);

impl ::std::fmt::Debug for ArvGcEnumEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcEnumEntry @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcEnumeration(c_void);

impl ::std::fmt::Debug for ArvGcEnumeration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcEnumeration @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFeatureNode {
    pub parent_instance: ArvGcNode,
}

impl ::std::fmt::Debug for ArvGcFeatureNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcFeatureNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcFloatNode(c_void);

impl ::std::fmt::Debug for ArvGcFloatNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcFloatNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcFloatRegNode {
    pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcFloatRegNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcFloatRegNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcGroupNode(c_void);

impl ::std::fmt::Debug for ArvGcGroupNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcGroupNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcIndexNode(c_void);

impl ::std::fmt::Debug for ArvGcIndexNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIndexNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcIntConverterNode(c_void);

impl ::std::fmt::Debug for ArvGcIntConverterNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntConverterNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntRegNode {
    pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcIntRegNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntRegNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcIntSwissKnifeNode {
    pub parent_instance: ArvGcSwissKnife,
}

impl ::std::fmt::Debug for ArvGcIntSwissKnifeNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntSwissKnifeNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcIntegerNode(c_void);

impl ::std::fmt::Debug for ArvGcIntegerNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcIntegerNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcInvalidatorNode(c_void);

impl ::std::fmt::Debug for ArvGcInvalidatorNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcInvalidatorNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcMaskedIntRegNode {
    pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcMaskedIntRegNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcMaskedIntRegNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcNode {
    pub parent_instance: ArvDomElement,
}

impl ::std::fmt::Debug for ArvGcNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcPort(c_void);

impl ::std::fmt::Debug for ArvGcPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcPort @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcPropertyNode {
    pub parent_instance: ArvGcNode,
}

impl ::std::fmt::Debug for ArvGcPropertyNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcPropertyNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcRegisterDescriptionNode(c_void);

impl ::std::fmt::Debug for ArvGcRegisterDescriptionNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcRegisterDescriptionNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcRegisterNode {
    pub parent_instance: ArvGcFeatureNode,
}

impl ::std::fmt::Debug for ArvGcRegisterNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcRegisterNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStringRegNode {
    pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcStringRegNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcStringRegNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcStructEntryNode(c_void);

impl ::std::fmt::Debug for ArvGcStructEntryNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcStructEntryNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcStructRegNode {
    pub parent_instance: ArvGcRegisterNode,
}

impl ::std::fmt::Debug for ArvGcStructRegNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcStructRegNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnife {
    pub parent_instance: ArvGcFeatureNode,
}

impl ::std::fmt::Debug for ArvGcSwissKnife {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcSwissKnife @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvGcSwissKnifeNode {
    pub parent_instance: ArvGcSwissKnife,
}

impl ::std::fmt::Debug for ArvGcSwissKnifeNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcSwissKnifeNode @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvGcValueIndexedNode(c_void);

impl ::std::fmt::Debug for ArvGcValueIndexedNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGcValueIndexedNode @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGvDevice(c_void);

impl ::std::fmt::Debug for ArvGvDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvDevice @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGvFakeCamera(c_void);

impl ::std::fmt::Debug for ArvGvFakeCamera {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvFakeCamera @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGvInterface(c_void);

impl ::std::fmt::Debug for ArvGvInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvGvStream(c_void);

impl ::std::fmt::Debug for ArvGvStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvGvStream @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvInterface {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvInterface @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArvStream {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for ArvStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvStream @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct ArvUvDevice(c_void);

impl ::std::fmt::Debug for ArvUvDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvUvDevice @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvUvInterface(c_void);

impl ::std::fmt::Debug for ArvUvInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvUvInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvUvStream(c_void);

impl ::std::fmt::Debug for ArvUvStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvUvStream @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct ArvXmlSchema(c_void);

impl ::std::fmt::Debug for ArvXmlSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ArvXmlSchema @ {:?}", self as *const _))
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct ArvGcFloat(c_void);

impl ::std::fmt::Debug for ArvGcFloat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "ArvGcFloat @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct ArvGcInteger(c_void);

impl ::std::fmt::Debug for ArvGcInteger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "ArvGcInteger @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct ArvGcRegister(c_void);

impl ::std::fmt::Debug for ArvGcRegister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "ArvGcRegister @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct ArvGcSelector(c_void);

impl ::std::fmt::Debug for ArvGcSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "ArvGcSelector @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct ArvGcString(c_void);

impl ::std::fmt::Debug for ArvGcString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "ArvGcString @ {:?}", self as *const _)
    }
}


extern "C" {

    //=========================================================================
    // ArvAcquisitionMode
    //=========================================================================
    pub fn arv_acquisition_mode_get_type() -> GType;
    pub fn arv_acquisition_mode_from_string(string: *const c_char) -> ArvAcquisitionMode;
    pub fn arv_acquisition_mode_to_string(value: ArvAcquisitionMode) -> *const c_char;

    //=========================================================================
    // ArvAuto
    //=========================================================================
    pub fn arv_auto_get_type() -> GType;
    pub fn arv_auto_from_string(string: *const c_char) -> ArvAuto;
    pub fn arv_auto_to_string(value: ArvAuto) -> *const c_char;

    //=========================================================================
    // ArvBufferPayloadType
    //=========================================================================
    pub fn arv_buffer_payload_type_get_type() -> GType;

    //=========================================================================
    // ArvBufferStatus
    //=========================================================================
    pub fn arv_buffer_status_get_type() -> GType;

    //=========================================================================
    // ArvChunkParserError
    //=========================================================================
    pub fn arv_chunk_parser_error_get_type() -> GType;

    //=========================================================================
    // ArvDebugLevel
    //=========================================================================
    pub fn arv_debug_level_get_type() -> GType;

    //=========================================================================
    // ArvDomNodeType
    //=========================================================================
    pub fn arv_dom_node_type_get_type() -> GType;

    //=========================================================================
    // ArvGcAccessMode
    //=========================================================================
    pub fn arv_gc_access_mode_get_type() -> GType;

    //=========================================================================
    // ArvGcCachable
    //=========================================================================
    pub fn arv_gc_cachable_get_type() -> GType;

    //=========================================================================
    // ArvGcError
    //=========================================================================
    pub fn arv_gc_error_get_type() -> GType;
    pub fn arv_gc_error_quark() -> glib::GQuark;

    //=========================================================================
    // ArvGcIsLinear
    //=========================================================================
    pub fn arv_gc_is_linear_get_type() -> GType;

    //=========================================================================
    // ArvGcNameSpace
    //=========================================================================
    pub fn arv_gc_name_space_get_type() -> GType;

    //=========================================================================
    // ArvGcPropertyNodeType
    //=========================================================================
    pub fn arv_gc_property_node_type_get_type() -> GType;

    //=========================================================================
    // ArvGcSignedness
    //=========================================================================
    pub fn arv_gc_signedness_get_type() -> GType;

    //=========================================================================
    // ArvGvStreamOption
    //=========================================================================
    pub fn arv_gv_stream_option_get_type() -> GType;

    //=========================================================================
    // ArvGvStreamPacketResend
    //=========================================================================
    pub fn arv_gv_stream_packet_resend_get_type() -> GType;

    //=========================================================================
    // ArvGvStreamSocketBuffer
    //=========================================================================
    pub fn arv_gv_stream_socket_buffer_get_type() -> GType;

    //=========================================================================
    // ArvRegisterCachePolicy
    //=========================================================================
    pub fn arv_register_cache_policy_get_type() -> GType;

    //=========================================================================
    // ArvStatus
    //=========================================================================
    pub fn arv_status_get_type() -> GType;

    //=========================================================================
    // ArvStreamCallbackType
    //=========================================================================
    pub fn arv_stream_callback_type_get_type() -> GType;

    //=========================================================================
    // ArvXmlSchemaError
    //=========================================================================
    pub fn arv_xml_schema_error_get_type() -> GType;

    //=========================================================================
    // ArvBuffer
    //=========================================================================
    pub fn arv_buffer_get_type() -> GType;
    pub fn arv_buffer_new(size: size_t, preallocated: *mut c_void) -> *mut ArvBuffer;
    pub fn arv_buffer_new_allocate(size: size_t) -> *mut ArvBuffer;
    pub fn arv_buffer_new_full(size: size_t, preallocated: *mut c_void, user_data: *mut c_void, user_data_destroy_func: glib::GDestroyNotify) -> *mut ArvBuffer;
    pub fn arv_buffer_get_chunk_data(buffer: *mut ArvBuffer, chunk_id: u64, size: *mut size_t) -> *mut u8;
    pub fn arv_buffer_get_data(buffer: *mut ArvBuffer, size: *mut size_t) -> *mut u8;
    pub fn arv_buffer_get_frame_id(buffer: *mut ArvBuffer) -> u32;
    pub fn arv_buffer_get_image_height(buffer: *mut ArvBuffer) -> c_int;
    pub fn arv_buffer_get_image_pixel_format(buffer: *mut ArvBuffer) -> ArvPixelFormat;
    pub fn arv_buffer_get_image_region(buffer: *mut ArvBuffer, x: *mut c_int, y: *mut c_int, width: *mut c_int, height: *mut c_int);
    pub fn arv_buffer_get_image_width(buffer: *mut ArvBuffer) -> c_int;
    pub fn arv_buffer_get_image_x(buffer: *mut ArvBuffer) -> c_int;
    pub fn arv_buffer_get_image_y(buffer: *mut ArvBuffer) -> c_int;
    pub fn arv_buffer_get_payload_type(buffer: *mut ArvBuffer) -> ArvBufferPayloadType;
    pub fn arv_buffer_get_status(buffer: *mut ArvBuffer) -> ArvBufferStatus;
    pub fn arv_buffer_get_system_timestamp(buffer: *mut ArvBuffer) -> u64;
    pub fn arv_buffer_get_timestamp(buffer: *mut ArvBuffer) -> u64;
    pub fn arv_buffer_get_user_data(buffer: *mut ArvBuffer) -> *mut c_void;
    pub fn arv_buffer_has_chunks(buffer: *mut ArvBuffer) -> gboolean;
    pub fn arv_buffer_set_system_timestamp(buffer: *mut ArvBuffer, timestamp_ns: u64);
    pub fn arv_buffer_set_timestamp(buffer: *mut ArvBuffer, timestamp_ns: u64);

    //=========================================================================
    // ArvCamera
    //=========================================================================
    pub fn arv_camera_get_type() -> GType;
    pub fn arv_camera_new(name: *const c_char) -> *mut ArvCamera;
    pub fn arv_camera_abort_acquisition(camera: *mut ArvCamera);
    pub fn arv_camera_acquisition(camera: *mut ArvCamera, timeout: u64) -> *mut ArvBuffer;
    pub fn arv_camera_clear_triggers(camera: *mut ArvCamera);
    pub fn arv_camera_create_chunk_parser(camera: *mut ArvCamera) -> *mut ArvChunkParser;
    pub fn arv_camera_create_stream(camera: *mut ArvCamera, callback: ArvStreamCallback, user_data: *mut c_void) -> *mut ArvStream;
    pub fn arv_camera_execute_command(camera: *mut ArvCamera, feature: *const c_char);
    pub fn arv_camera_get_acquisition_mode(camera: *mut ArvCamera) -> ArvAcquisitionMode;
    pub fn arv_camera_get_available_enumerations(camera: *mut ArvCamera, feature: *const c_char, n_values: *mut c_uint) -> *mut i64;
    pub fn arv_camera_get_available_enumerations_as_display_names(camera: *mut ArvCamera, feature: *const c_char, n_values: *mut c_uint) -> *mut *const c_char;
    pub fn arv_camera_get_available_enumerations_as_strings(camera: *mut ArvCamera, feature: *const c_char, n_values: *mut c_uint) -> *mut *const c_char;
    pub fn arv_camera_get_available_pixel_formats(camera: *mut ArvCamera, n_pixel_formats: *mut c_uint) -> *mut i64;
    pub fn arv_camera_get_available_pixel_formats_as_display_names(camera: *mut ArvCamera, n_pixel_formats: *mut c_uint) -> *mut *const c_char;
    pub fn arv_camera_get_available_pixel_formats_as_strings(camera: *mut ArvCamera, n_pixel_formats: *mut c_uint) -> *mut *const c_char;
    pub fn arv_camera_get_available_trigger_sources(camera: *mut ArvCamera, n_sources: *mut c_uint) -> *mut *const c_char;
    pub fn arv_camera_get_available_triggers(camera: *mut ArvCamera, n_triggers: *mut c_uint) -> *mut *const c_char;
    pub fn arv_camera_get_binning(camera: *mut ArvCamera, dx: *mut c_int, dy: *mut c_int);
    pub fn arv_camera_get_boolean(camera: *mut ArvCamera, feature: *const c_char) -> gboolean;
    pub fn arv_camera_get_chunk_mode(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_get_chunk_state(camera: *mut ArvCamera, chunk: *const c_char) -> gboolean;
    pub fn arv_camera_get_device(camera: *mut ArvCamera) -> *mut ArvDevice;
    pub fn arv_camera_get_device_id(camera: *mut ArvCamera) -> *const c_char;
    pub fn arv_camera_get_exposure_time(camera: *mut ArvCamera) -> c_double;
    pub fn arv_camera_get_exposure_time_auto(camera: *mut ArvCamera) -> ArvAuto;
    pub fn arv_camera_get_exposure_time_bounds(camera: *mut ArvCamera, min: *mut c_double, max: *mut c_double);
    pub fn arv_camera_get_float(camera: *mut ArvCamera, feature: *const c_char) -> c_double;
    pub fn arv_camera_get_float_bounds(camera: *mut ArvCamera, feature: *const c_char, min: *mut c_double, max: *mut c_double);
    pub fn arv_camera_get_frame_count(camera: *mut ArvCamera) -> i64;
    pub fn arv_camera_get_frame_count_bounds(camera: *mut ArvCamera, min: *mut i64, max: *mut i64);
    pub fn arv_camera_get_frame_rate(camera: *mut ArvCamera) -> c_double;
    pub fn arv_camera_get_frame_rate_bounds(camera: *mut ArvCamera, min: *mut c_double, max: *mut c_double);
    pub fn arv_camera_get_gain(camera: *mut ArvCamera) -> c_double;
    pub fn arv_camera_get_gain_auto(camera: *mut ArvCamera) -> ArvAuto;
    pub fn arv_camera_get_gain_bounds(camera: *mut ArvCamera, min: *mut c_double, max: *mut c_double);
    pub fn arv_camera_get_height_bounds(camera: *mut ArvCamera, min: *mut c_int, max: *mut c_int);
    pub fn arv_camera_get_height_increment(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_get_integer(camera: *mut ArvCamera, feature: *const c_char) -> i64;
    pub fn arv_camera_get_integer_bounds(camera: *mut ArvCamera, feature: *const c_char, min: *mut i64, max: *mut i64);
    pub fn arv_camera_get_integer_increment(camera: *mut ArvCamera, feature: *const c_char) -> i64;
    pub fn arv_camera_get_model_name(camera: *mut ArvCamera) -> *const c_char;
    pub fn arv_camera_get_payload(camera: *mut ArvCamera) -> c_uint;
    pub fn arv_camera_get_pixel_format(camera: *mut ArvCamera) -> ArvPixelFormat;
    pub fn arv_camera_get_pixel_format_as_string(camera: *mut ArvCamera) -> *const c_char;
    pub fn arv_camera_get_region(camera: *mut ArvCamera, x: *mut c_int, y: *mut c_int, width: *mut c_int, height: *mut c_int);
    pub fn arv_camera_get_sensor_size(camera: *mut ArvCamera, width: *mut c_int, height: *mut c_int);
    pub fn arv_camera_get_status(camera: *mut ArvCamera, error: *mut *mut glib::GError) -> ArvStatus;
    pub fn arv_camera_get_string(camera: *mut ArvCamera, feature: *const c_char) -> *const c_char;
    pub fn arv_camera_get_trigger_source(camera: *mut ArvCamera) -> *const c_char;
    pub fn arv_camera_get_vendor_name(camera: *mut ArvCamera) -> *const c_char;
    pub fn arv_camera_get_width_bounds(camera: *mut ArvCamera, min: *mut c_int, max: *mut c_int);
    pub fn arv_camera_get_width_increment(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_get_x_binning_bounds(camera: *mut ArvCamera, min: *mut c_int, max: *mut c_int);
    pub fn arv_camera_get_x_binning_increment(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_get_x_offset_bounds(camera: *mut ArvCamera, min: *mut c_int, max: *mut c_int);
    pub fn arv_camera_get_x_offset_increment(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_get_y_binning_bounds(camera: *mut ArvCamera, min: *mut c_int, max: *mut c_int);
    pub fn arv_camera_get_y_binning_increment(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_get_y_offset_bounds(camera: *mut ArvCamera, min: *mut c_int, max: *mut c_int);
    pub fn arv_camera_get_y_offset_increment(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_gv_auto_packet_size(camera: *mut ArvCamera) -> c_uint;
    pub fn arv_camera_gv_get_current_stream_channel(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_gv_get_n_stream_channels(camera: *mut ArvCamera) -> c_int;
    pub fn arv_camera_gv_get_packet_delay(camera: *mut ArvCamera) -> i64;
    pub fn arv_camera_gv_get_packet_size(camera: *mut ArvCamera) -> c_uint;
    pub fn arv_camera_gv_select_stream_channel(camera: *mut ArvCamera, channel_id: c_int);
    pub fn arv_camera_gv_set_packet_delay(camera: *mut ArvCamera, delay_ns: i64);
    pub fn arv_camera_gv_set_packet_size(camera: *mut ArvCamera, packet_size: c_int);
    pub fn arv_camera_gv_set_stream_options(camera: *mut ArvCamera, options: ArvGvStreamOption);
    pub fn arv_camera_is_binning_available(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_is_exposure_auto_available(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_is_exposure_time_available(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_is_feature_available(camera: *mut ArvCamera, feature: *const c_char) -> gboolean;
    pub fn arv_camera_is_frame_rate_available(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_is_gain_auto_available(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_is_gain_available(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_is_gv_device(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_is_uv_device(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_set_acquisition_mode(camera: *mut ArvCamera, value: ArvAcquisitionMode);
    pub fn arv_camera_set_binning(camera: *mut ArvCamera, dx: c_int, dy: c_int);
    pub fn arv_camera_set_boolean(camera: *mut ArvCamera, feature: *const c_char, value: gboolean);
    pub fn arv_camera_set_chunk_mode(camera: *mut ArvCamera, is_active: gboolean);
    pub fn arv_camera_set_chunk_state(camera: *mut ArvCamera, chunk: *const c_char, is_enabled: gboolean);
    pub fn arv_camera_set_chunks(camera: *mut ArvCamera, chunk_list: *const c_char);
    pub fn arv_camera_set_exposure_time(camera: *mut ArvCamera, exposure_time_us: c_double);
    pub fn arv_camera_set_exposure_time_auto(camera: *mut ArvCamera, auto_mode: ArvAuto);
    pub fn arv_camera_set_float(camera: *mut ArvCamera, feature: *const c_char, value: c_double);
    pub fn arv_camera_set_frame_count(camera: *mut ArvCamera, frame_count: i64);
    pub fn arv_camera_set_frame_rate(camera: *mut ArvCamera, frame_rate: c_double);
    pub fn arv_camera_set_gain(camera: *mut ArvCamera, gain: c_double);
    pub fn arv_camera_set_gain_auto(camera: *mut ArvCamera, auto_mode: ArvAuto);
    pub fn arv_camera_set_integer(camera: *mut ArvCamera, feature: *const c_char, value: i64);
    pub fn arv_camera_set_pixel_format(camera: *mut ArvCamera, format: ArvPixelFormat);
    pub fn arv_camera_set_pixel_format_from_string(camera: *mut ArvCamera, format: *const c_char);
    pub fn arv_camera_set_region(camera: *mut ArvCamera, x: c_int, y: c_int, width: c_int, height: c_int);
    pub fn arv_camera_set_string(camera: *mut ArvCamera, feature: *const c_char, value: *const c_char);
    pub fn arv_camera_set_trigger(camera: *mut ArvCamera, source: *const c_char);
    pub fn arv_camera_set_trigger_source(camera: *mut ArvCamera, source: *const c_char);
    pub fn arv_camera_software_trigger(camera: *mut ArvCamera);
    pub fn arv_camera_start_acquisition(camera: *mut ArvCamera);
    pub fn arv_camera_stop_acquisition(camera: *mut ArvCamera);
    pub fn arv_camera_uv_get_bandwidth(camera: *mut ArvCamera) -> c_uint;
    pub fn arv_camera_uv_get_bandwidth_bounds(camera: *mut ArvCamera, min: *mut c_uint, max: *mut c_uint);
    pub fn arv_camera_uv_is_bandwidth_control_available(camera: *mut ArvCamera) -> gboolean;
    pub fn arv_camera_uv_set_bandwidth(camera: *mut ArvCamera, bandwidth: c_uint);

    //=========================================================================
    // ArvChunkParser
    //=========================================================================
    pub fn arv_chunk_parser_get_type() -> GType;
    pub fn arv_chunk_parser_new(xml: *const c_char, size: size_t) -> *mut ArvChunkParser;
    pub fn arv_chunk_parser_get_boolean_value(parser: *mut ArvChunkParser, buffer: *mut ArvBuffer, chunk: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_chunk_parser_get_float_value(parser: *mut ArvChunkParser, buffer: *mut ArvBuffer, chunk: *const c_char, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_chunk_parser_get_integer_value(parser: *mut ArvChunkParser, buffer: *mut ArvBuffer, chunk: *const c_char, error: *mut *mut glib::GError) -> i64;
    pub fn arv_chunk_parser_get_string_value(parser: *mut ArvChunkParser, buffer: *mut ArvBuffer, chunk: *const c_char, error: *mut *mut glib::GError) -> *const c_char;

    //=========================================================================
    // ArvDevice
    //=========================================================================
    pub fn arv_device_get_type() -> GType;
    pub fn arv_device_create_chunk_parser(device: *mut ArvDevice) -> *mut ArvChunkParser;
    pub fn arv_device_create_stream(device: *mut ArvDevice, callback: ArvStreamCallback, user_data: *mut c_void) -> *mut ArvStream;
    pub fn arv_device_execute_command(device: *mut ArvDevice, feature: *const c_char, error: *mut *mut glib::GError);
    pub fn arv_device_get_available_enumeration_feature_values(device: *mut ArvDevice, feature: *const c_char, n_values: *mut c_uint, error: *mut *mut glib::GError) -> *mut i64;
    pub fn arv_device_get_available_enumeration_feature_values_as_display_names(device: *mut ArvDevice, feature: *const c_char, n_values: *mut c_uint, error: *mut *mut glib::GError) -> *mut *const c_char;
    pub fn arv_device_get_available_enumeration_feature_values_as_strings(device: *mut ArvDevice, feature: *const c_char, n_values: *mut c_uint, error: *mut *mut glib::GError) -> *mut *const c_char;
    pub fn arv_device_get_boolean_feature_value(device: *mut ArvDevice, feature: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_device_get_feature(device: *mut ArvDevice, feature: *const c_char) -> *mut ArvGcNode;
    pub fn arv_device_get_float_feature_bounds(device: *mut ArvDevice, feature: *const c_char, min: *mut c_double, max: *mut c_double, error: *mut *mut glib::GError);
    pub fn arv_device_get_float_feature_value(device: *mut ArvDevice, feature: *const c_char, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_device_get_genicam(device: *mut ArvDevice) -> *mut ArvGc;
    pub fn arv_device_get_genicam_xml(device: *mut ArvDevice, size: *mut size_t) -> *const c_char;
    pub fn arv_device_get_integer_feature_bounds(device: *mut ArvDevice, feature: *const c_char, min: *mut i64, max: *mut i64, error: *mut *mut glib::GError);
    pub fn arv_device_get_integer_feature_increment(device: *mut ArvDevice, feature: *const c_char, error: *mut *mut glib::GError) -> i64;
    pub fn arv_device_get_integer_feature_value(device: *mut ArvDevice, feature: *const c_char, error: *mut *mut glib::GError) -> i64;
    pub fn arv_device_get_string_feature_value(device: *mut ArvDevice, feature: *const c_char, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_device_read_memory(device: *mut ArvDevice, address: u64, size: u32, buffer: *mut c_void, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_device_read_register(device: *mut ArvDevice, address: u64, value: *mut u32, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_device_set_boolean_feature_value(device: *mut ArvDevice, feature: *const c_char, value: gboolean, error: *mut *mut glib::GError);
    pub fn arv_device_set_float_feature_value(device: *mut ArvDevice, feature: *const c_char, value: c_double, error: *mut *mut glib::GError);
    pub fn arv_device_set_integer_feature_value(device: *mut ArvDevice, feature: *const c_char, value: i64, error: *mut *mut glib::GError);
    pub fn arv_device_set_register_cache_policy(device: *mut ArvDevice, policy: ArvRegisterCachePolicy);
    pub fn arv_device_set_string_feature_value(device: *mut ArvDevice, feature: *const c_char, value: *const c_char, error: *mut *mut glib::GError);
    pub fn arv_device_write_memory(device: *mut ArvDevice, address: u64, size: u32, buffer: *mut c_void, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_device_write_register(device: *mut ArvDevice, address: u64, value: u32, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // ArvDomCharacterData
    //=========================================================================
    pub fn arv_dom_character_data_get_type() -> GType;
    pub fn arv_dom_character_data_get_data(self_: *mut ArvDomCharacterData) -> *const c_char;
    pub fn arv_dom_character_data_set_data(self_: *mut ArvDomCharacterData, value: *const c_char);

    //=========================================================================
    // ArvDomDocument
    //=========================================================================
    pub fn arv_dom_document_get_type() -> GType;
    pub fn arv_dom_document_new_from_memory(buffer: *mut c_void, size: c_int, error: *mut *mut glib::GError) -> *mut ArvDomDocument;
    pub fn arv_dom_document_new_from_path(path: *const c_char, error: *mut *mut glib::GError) -> *mut ArvDomDocument;
    pub fn arv_dom_document_new_from_url(url: *const c_char, error: *mut *mut glib::GError) -> *mut ArvDomDocument;
    pub fn arv_dom_document_append_from_memory(document: *mut ArvDomDocument, node: *mut ArvDomNode, buffer: *mut c_void, size: c_int, error: *mut *mut glib::GError);
    pub fn arv_dom_document_create_element(self_: *mut ArvDomDocument, tag_name: *const c_char) -> *mut ArvDomElement;
    pub fn arv_dom_document_create_text_node(self_: *mut ArvDomDocument, data: *const c_char) -> *mut ArvDomText;
    pub fn arv_dom_document_get_document_element(self_: *mut ArvDomDocument) -> *mut ArvDomElement;
    pub fn arv_dom_document_get_href_data(self_: *mut ArvDomDocument, href: *const c_char, size: *mut size_t) -> *mut c_void;
    pub fn arv_dom_document_get_url(self_: *mut ArvDomDocument) -> *const c_char;
    pub fn arv_dom_document_save_to_memory(documennt: *mut ArvDomDocument, buffer: *mut *mut c_void, size: *mut c_int, error: *mut *mut glib::GError);
    pub fn arv_dom_document_save_to_path(documennt: *mut ArvDomDocument, path: *const c_char, error: *mut *mut glib::GError);
    pub fn arv_dom_document_save_to_stream(document: *mut ArvDomDocument, stream: *mut gio::GOutputStream, error: *mut *mut glib::GError);
    pub fn arv_dom_document_save_to_url(documennt: *mut ArvDomDocument, path: *const c_char, error: *mut *mut glib::GError);
    pub fn arv_dom_document_set_path(self_: *mut ArvDomDocument, path: *const c_char);
    pub fn arv_dom_document_set_url(self_: *mut ArvDomDocument, url: *const c_char);

    //=========================================================================
    // ArvDomDocumentFragment
    //=========================================================================
    pub fn arv_dom_document_fragment_get_type() -> GType;
    pub fn arv_dom_document_fragment_new() -> *mut ArvDomDocumentFragment;

    //=========================================================================
    // ArvDomElement
    //=========================================================================
    pub fn arv_dom_element_get_type() -> GType;
    pub fn arv_dom_element_get_attribute(self_: *mut ArvDomElement, name: *const c_char) -> *const c_char;
    pub fn arv_dom_element_get_tag_name(self_: *mut ArvDomElement) -> *const c_char;
    pub fn arv_dom_element_set_attribute(self_: *mut ArvDomElement, name: *const c_char, attribute_value: *const c_char);

    //=========================================================================
    // ArvDomNamedNodeMap
    //=========================================================================
    pub fn arv_dom_named_node_map_get_type() -> GType;
    pub fn arv_dom_named_node_map_get_item(map: *mut ArvDomNamedNodeMap, index: c_uint) -> *mut ArvDomNode;
    pub fn arv_dom_named_node_map_get_length(map: *mut ArvDomNamedNodeMap) -> c_uint;
    pub fn arv_dom_named_node_map_get_named_item(map: *mut ArvDomNamedNodeMap, name: *const c_char) -> *mut ArvDomNode;
    pub fn arv_dom_named_node_map_remove_named_item(map: *mut ArvDomNamedNodeMap, name: *const c_char) -> *mut ArvDomNode;
    pub fn arv_dom_named_node_map_set_named_item(map: *mut ArvDomNamedNodeMap, item: *mut ArvDomNode) -> *mut ArvDomNode;

    //=========================================================================
    // ArvDomNode
    //=========================================================================
    pub fn arv_dom_node_get_type() -> GType;
    pub fn arv_dom_node_append_child(self_: *mut ArvDomNode, new_child: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_changed(self_: *mut ArvDomNode);
    pub fn arv_dom_node_get_child_nodes(self_: *mut ArvDomNode) -> *mut ArvDomNodeList;
    pub fn arv_dom_node_get_first_child(self_: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_get_last_child(self_: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_get_next_sibling(self_: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_get_node_name(self_: *mut ArvDomNode) -> *const c_char;
    pub fn arv_dom_node_get_node_type(self_: *mut ArvDomNode) -> ArvDomNodeType;
    pub fn arv_dom_node_get_node_value(self_: *mut ArvDomNode) -> *const c_char;
    pub fn arv_dom_node_get_owner_document(self_: *mut ArvDomNode) -> *mut ArvDomDocument;
    pub fn arv_dom_node_get_parent_node(self_: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_get_previous_sibling(self_: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_has_child_nodes(self_: *mut ArvDomNode) -> gboolean;
    pub fn arv_dom_node_insert_before(self_: *mut ArvDomNode, new_child: *mut ArvDomNode, ref_child: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_remove_child(self_: *mut ArvDomNode, old_child: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_replace_child(self_: *mut ArvDomNode, new_child: *mut ArvDomNode, old_child: *mut ArvDomNode) -> *mut ArvDomNode;
    pub fn arv_dom_node_set_node_value(self_: *mut ArvDomNode, new_value: *const c_char);
    pub fn arv_dom_node_write_to_stream(self_: *mut ArvDomNode, stream: *mut gio::GOutputStream, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvDomNodeList
    //=========================================================================
    pub fn arv_dom_node_list_get_type() -> GType;
    pub fn arv_dom_node_list_get_item(list: *mut ArvDomNodeList, index: c_uint) -> *mut ArvDomNode;
    pub fn arv_dom_node_list_get_length(list: *mut ArvDomNodeList) -> c_uint;

    //=========================================================================
    // ArvDomText
    //=========================================================================
    pub fn arv_dom_text_get_type() -> GType;
    pub fn arv_dom_text_new(data: *const c_char) -> *mut ArvDomNode;

    //=========================================================================
    // ArvEvaluator
    //=========================================================================
    pub fn arv_evaluator_get_type() -> GType;
    pub fn arv_evaluator_new(expression: *const c_char) -> *mut ArvEvaluator;
    pub fn arv_evaluator_evaluate_as_double(evaluator: *mut ArvEvaluator, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_evaluator_evaluate_as_int64(evaluator: *mut ArvEvaluator, error: *mut *mut glib::GError) -> i64;
    pub fn arv_evaluator_get_constant(evaluator: *mut ArvEvaluator, name: *const c_char) -> *const c_char;
    pub fn arv_evaluator_get_expression(evaluator: *mut ArvEvaluator) -> *const c_char;
    pub fn arv_evaluator_get_sub_expression(evaluator: *mut ArvEvaluator, name: *const c_char) -> *const c_char;
    pub fn arv_evaluator_set_constant(evaluator: *mut ArvEvaluator, name: *const c_char, constant: *const c_char);
    pub fn arv_evaluator_set_double_variable(evaluator: *mut ArvEvaluator, name: *const c_char, v_double: c_double);
    pub fn arv_evaluator_set_expression(evaluator: *mut ArvEvaluator, expression: *const c_char);
    pub fn arv_evaluator_set_int64_variable(evaluator: *mut ArvEvaluator, name: *const c_char, v_int64: i64);
    pub fn arv_evaluator_set_sub_expression(evaluator: *mut ArvEvaluator, name: *const c_char, expression: *const c_char);

    //=========================================================================
    // ArvFakeCamera
    //=========================================================================
    pub fn arv_fake_camera_get_type() -> GType;
    pub fn arv_fake_camera_new(serial_number: *const c_char) -> *mut ArvFakeCamera;
    pub fn arv_fake_camera_new_full(serial_number: *const c_char, genicam_filename: *const c_char) -> *mut ArvFakeCamera;
    pub fn arv_fake_camera_fill_buffer(camera: *mut ArvFakeCamera, buffer: *mut ArvBuffer, packet_size: *mut u32);
    pub fn arv_fake_camera_get_acquisition_status(camera: *mut ArvFakeCamera) -> u32;
    pub fn arv_fake_camera_get_control_channel_privilege(camera: *mut ArvFakeCamera) -> u32;
    pub fn arv_fake_camera_get_genicam_xml(camera: *mut ArvFakeCamera, size: *mut size_t) -> *const c_char;
    pub fn arv_fake_camera_get_heartbeat_timeout(camera: *mut ArvFakeCamera) -> u32;
    pub fn arv_fake_camera_get_payload(camera: *mut ArvFakeCamera) -> size_t;
    pub fn arv_fake_camera_get_sleep_time_for_next_frame(camera: *mut ArvFakeCamera, next_timestamp_us: *mut u64) -> u64;
    pub fn arv_fake_camera_get_stream_address(camera: *mut ArvFakeCamera) -> *mut gio::GSocketAddress;
    pub fn arv_fake_camera_read_memory(camera: *mut ArvFakeCamera, address: u32, size: u32, buffer: *mut c_void) -> gboolean;
    pub fn arv_fake_camera_read_register(camera: *mut ArvFakeCamera, address: u32, value: *mut u32) -> gboolean;
    pub fn arv_fake_camera_set_control_channel_privilege(camera: *mut ArvFakeCamera, privilege: u32);
    pub fn arv_fake_camera_set_fill_pattern(camera: *mut ArvFakeCamera, fill_pattern_callback: ArvFakeCameraFillPattern, fill_pattern_data: *mut c_void);
    pub fn arv_fake_camera_set_inet_address(camera: *mut ArvFakeCamera, address: *mut gio::GInetAddress);
    pub fn arv_fake_camera_set_trigger_frequency(camera: *mut ArvFakeCamera, frequency: c_double);
    pub fn arv_fake_camera_wait_for_next_frame(camera: *mut ArvFakeCamera);
    pub fn arv_fake_camera_write_memory(camera: *mut ArvFakeCamera, address: u32, size: u32, buffer: *mut c_void) -> gboolean;
    pub fn arv_fake_camera_write_register(camera: *mut ArvFakeCamera, address: u32, value: u32) -> gboolean;

    //=========================================================================
    // ArvFakeDevice
    //=========================================================================
    pub fn arv_fake_device_get_type() -> GType;
    pub fn arv_fake_device_new(serial_number: *const c_char) -> *mut ArvDevice;
    pub fn arv_fake_device_get_fake_camera(device: *mut ArvFakeDevice) -> *mut ArvFakeCamera;

    //=========================================================================
    // ArvFakeInterface
    //=========================================================================
    pub fn arv_fake_interface_get_type() -> GType;
    pub fn arv_fake_interface_get_instance() -> *mut ArvInterface;

    //=========================================================================
    // ArvFakeStream
    //=========================================================================
    pub fn arv_fake_stream_get_type() -> GType;

    //=========================================================================
    // ArvGc
    //=========================================================================
    pub fn arv_gc_get_type() -> GType;
    pub fn arv_gc_new(device: *mut ArvDevice, xml: *mut c_void, size: size_t) -> *mut ArvGc;
    pub fn arv_gc_p_value_indexed_node_new() -> *mut ArvGcNode;
    pub fn arv_gc_invalidator_has_changed(self_: *mut ArvGcInvalidatorNode) -> gboolean;
    pub fn arv_gc_get_buffer(genicam: *mut ArvGc) -> *mut ArvBuffer;
    pub fn arv_gc_get_device(genicam: *mut ArvGc) -> *mut ArvDevice;
    pub fn arv_gc_get_node(genicam: *mut ArvGc, name: *const c_char) -> *mut ArvGcNode;
    pub fn arv_gc_get_register_cache_policy(genicam: *mut ArvGc) -> ArvRegisterCachePolicy;
    pub fn arv_gc_register_feature_node(genicam: *mut ArvGc, node: *mut ArvGcFeatureNode);
    pub fn arv_gc_set_buffer(genicam: *mut ArvGc, buffer: *mut ArvBuffer);
    pub fn arv_gc_set_default_node_data(genicam: *mut ArvGc, node_name: *const c_char, ...);
    pub fn arv_gc_set_register_cache_policy(genicam: *mut ArvGc, policy: ArvRegisterCachePolicy);

    //=========================================================================
    // ArvGcBoolean
    //=========================================================================
    pub fn arv_gc_boolean_get_type() -> GType;
    pub fn arv_gc_boolean_new() -> *mut ArvGcNode;
    pub fn arv_gc_boolean_get_value(gc_boolean: *mut ArvGcBoolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_gc_boolean_set_value(gc_boolean: *mut ArvGcBoolean, v_boolean: gboolean, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcCategory
    //=========================================================================
    pub fn arv_gc_category_get_type() -> GType;
    pub fn arv_gc_category_new() -> *mut ArvGcNode;
    pub fn arv_gc_category_get_features(category: *mut ArvGcCategory) -> *const glib::GSList;

    //=========================================================================
    // ArvGcCommand
    //=========================================================================
    pub fn arv_gc_command_get_type() -> GType;
    pub fn arv_gc_command_new() -> *mut ArvGcNode;
    pub fn arv_gc_command_execute(gc_command: *mut ArvGcCommand, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcConverter
    //=========================================================================
    pub fn arv_gc_converter_get_type() -> GType;

    //=========================================================================
    // ArvGcConverterNode
    //=========================================================================
    pub fn arv_gc_converter_node_get_type() -> GType;
    pub fn arv_gc_converter_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcEnumEntry
    //=========================================================================
    pub fn arv_gc_enum_entry_get_type() -> GType;
    pub fn arv_gc_enum_entry_new() -> *mut ArvGcNode;
    pub fn arv_gc_enum_entry_get_value(entry: *mut ArvGcEnumEntry, error: *mut *mut glib::GError) -> i64;

    //=========================================================================
    // ArvGcEnumeration
    //=========================================================================
    pub fn arv_gc_enumeration_get_type() -> GType;
    pub fn arv_gc_enumeration_new() -> *mut ArvGcNode;
    pub fn arv_gc_enumeration_get_available_display_names(enumeration: *mut ArvGcEnumeration, n_values: *mut c_uint, error: *mut *mut glib::GError) -> *mut *const c_char;
    pub fn arv_gc_enumeration_get_available_int_values(enumeration: *mut ArvGcEnumeration, n_values: *mut c_uint, error: *mut *mut glib::GError) -> *mut i64;
    pub fn arv_gc_enumeration_get_available_string_values(enumeration: *mut ArvGcEnumeration, n_values: *mut c_uint, error: *mut *mut glib::GError) -> *mut *const c_char;
    pub fn arv_gc_enumeration_get_entries(enumeration: *mut ArvGcEnumeration) -> *const glib::GSList;
    pub fn arv_gc_enumeration_get_int_value(enumeration: *mut ArvGcEnumeration, error: *mut *mut glib::GError) -> i64;
    pub fn arv_gc_enumeration_get_string_value(enumeration: *mut ArvGcEnumeration, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_enumeration_set_int_value(enumeration: *mut ArvGcEnumeration, value: i64, error: *mut *mut glib::GError);
    pub fn arv_gc_enumeration_set_string_value(enumeration: *mut ArvGcEnumeration, value: *const c_char, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcFeatureNode
    //=========================================================================
    pub fn arv_gc_feature_node_get_type() -> GType;
    pub fn arv_gc_feature_node_get_description(gc_feature_node: *mut ArvGcFeatureNode, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_feature_node_get_display_name(gc_feature_node: *mut ArvGcFeatureNode, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_feature_node_get_name(gc_feature_node: *mut ArvGcFeatureNode) -> *const c_char;
    pub fn arv_gc_feature_node_get_tooltip(gc_feature_node: *mut ArvGcFeatureNode, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_feature_node_get_value_as_string(gc_feature_node: *mut ArvGcFeatureNode, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_feature_node_is_available(gc_feature_node: *mut ArvGcFeatureNode, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_gc_feature_node_is_implemented(gc_feature_node: *mut ArvGcFeatureNode, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_gc_feature_node_is_locked(gc_feature_node: *mut ArvGcFeatureNode, error: *mut *mut glib::GError) -> gboolean;
    pub fn arv_gc_feature_node_set_value_from_string(gc_feature_node: *mut ArvGcFeatureNode, string: *const c_char, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcFloatNode
    //=========================================================================
    pub fn arv_gc_float_node_get_type() -> GType;
    pub fn arv_gc_float_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcFloatRegNode
    //=========================================================================
    pub fn arv_gc_float_reg_node_get_type() -> GType;
    pub fn arv_gc_float_reg_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcGroupNode
    //=========================================================================
    pub fn arv_gc_group_node_get_type() -> GType;
    pub fn arv_gc_group_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcIndexNode
    //=========================================================================
    pub fn arv_gc_index_node_get_type() -> GType;
    pub fn arv_gc_index_node_new() -> *mut ArvGcNode;
    pub fn arv_gc_index_node_get_index(index_node: *mut ArvGcIndexNode, default_offset: i64, error: *mut *mut glib::GError) -> i64;

    //=========================================================================
    // ArvGcIntConverterNode
    //=========================================================================
    pub fn arv_gc_int_converter_node_get_type() -> GType;
    pub fn arv_gc_int_converter_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcIntRegNode
    //=========================================================================
    pub fn arv_gc_int_reg_node_get_type() -> GType;
    pub fn arv_gc_int_reg_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcIntSwissKnifeNode
    //=========================================================================
    pub fn arv_gc_int_swiss_knife_node_get_type() -> GType;
    pub fn arv_gc_int_swiss_knife_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcIntegerNode
    //=========================================================================
    pub fn arv_gc_integer_node_get_type() -> GType;
    pub fn arv_gc_integer_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcInvalidatorNode
    //=========================================================================
    pub fn arv_gc_invalidator_node_get_type() -> GType;
    pub fn arv_gc_invalidator_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcMaskedIntRegNode
    //=========================================================================
    pub fn arv_gc_masked_int_reg_node_get_type() -> GType;
    pub fn arv_gc_masked_int_reg_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcNode
    //=========================================================================
    pub fn arv_gc_node_get_type() -> GType;
    pub fn arv_gc_node_get_genicam(gc_node: *mut ArvGcNode) -> *mut ArvGc;

    //=========================================================================
    // ArvGcPort
    //=========================================================================
    pub fn arv_gc_port_get_type() -> GType;
    pub fn arv_gc_port_new() -> *mut ArvGcNode;
    pub fn arv_gc_port_read(port: *mut ArvGcPort, buffer: *mut c_void, address: u64, length: u64, error: *mut *mut glib::GError);
    pub fn arv_gc_port_write(port: *mut ArvGcPort, buffer: *mut c_void, address: u64, length: u64, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcPropertyNode
    //=========================================================================
    pub fn arv_gc_property_node_get_type() -> GType;
    pub fn arv_gc_property_node_new_access_mode() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_address() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_bit() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_cachable() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_chunk_id() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_command_value() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_constant() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_description() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_display_name() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_endianess() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_event_id() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_expression() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_formula() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_formula_from() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_formula_to() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_imposed_access_mode() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_increment() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_is_linear() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_length() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_lsb() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_maximum() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_minimum() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_msb() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_off_value() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_on_value() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_address() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_command_value() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_feature() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_increment() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_is_available() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_is_implemented() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_is_locked() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_length() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_maximum() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_minimum() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_port() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_selected() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_value() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_value_default() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_p_variable() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_polling_time() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_sign() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_slope() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_tooltip() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_unit() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_value() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_new_value_default() -> *mut ArvGcNode;
    pub fn arv_gc_property_node_get_access_mode(self_: *mut ArvGcPropertyNode, default_value: ArvGcAccessMode) -> ArvGcAccessMode;
    pub fn arv_gc_property_node_get_cachable(self_: *mut ArvGcPropertyNode, default_value: ArvGcCachable) -> ArvGcCachable;
    pub fn arv_gc_property_node_get_double(node: *mut ArvGcPropertyNode, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_gc_property_node_get_endianess(self_: *mut ArvGcPropertyNode, default_value: c_uint) -> c_uint;
    pub fn arv_gc_property_node_get_int64(node: *mut ArvGcPropertyNode, error: *mut *mut glib::GError) -> i64;
    pub fn arv_gc_property_node_get_linked_node(node: *mut ArvGcPropertyNode) -> *mut ArvGcNode;
    pub fn arv_gc_property_node_get_lsb(self_: *mut ArvGcPropertyNode, default_value: c_uint) -> c_uint;
    pub fn arv_gc_property_node_get_msb(self_: *mut ArvGcPropertyNode, default_value: c_uint) -> c_uint;
    pub fn arv_gc_property_node_get_name(node: *mut ArvGcPropertyNode) -> *const c_char;
    pub fn arv_gc_property_node_get_node_type(node: *mut ArvGcPropertyNode) -> ArvGcPropertyNodeType;
    pub fn arv_gc_property_node_get_sign(self_: *mut ArvGcPropertyNode, default_value: ArvGcSignedness) -> ArvGcSignedness;
    pub fn arv_gc_property_node_get_string(node: *mut ArvGcPropertyNode, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_property_node_set_double(node: *mut ArvGcPropertyNode, v_double: c_double, error: *mut *mut glib::GError);
    pub fn arv_gc_property_node_set_int64(node: *mut ArvGcPropertyNode, v_int64: i64, error: *mut *mut glib::GError);
    pub fn arv_gc_property_node_set_string(node: *mut ArvGcPropertyNode, string: *const c_char, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcRegisterDescriptionNode
    //=========================================================================
    pub fn arv_gc_register_description_node_get_type() -> GType;
    pub fn arv_gc_register_description_node_new() -> *mut ArvGcNode;
    pub fn arv_gc_register_description_node_check_schema_version(node: *mut ArvGcRegisterDescriptionNode, required_major: c_uint, required_minor: c_uint, required_subminor: c_uint) -> gboolean;
    pub fn arv_gc_register_description_node_compare_schema_version(node: *mut ArvGcRegisterDescriptionNode, major: c_uint, minor: c_uint, subminor: c_uint) -> c_int;

    //=========================================================================
    // ArvGcRegisterNode
    //=========================================================================
    pub fn arv_gc_register_node_get_type() -> GType;
    pub fn arv_gc_register_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcStringRegNode
    //=========================================================================
    pub fn arv_gc_string_reg_node_get_type() -> GType;
    pub fn arv_gc_string_reg_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcStructEntryNode
    //=========================================================================
    pub fn arv_gc_struct_entry_node_get_type() -> GType;
    pub fn arv_gc_struct_entry_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcStructRegNode
    //=========================================================================
    pub fn arv_gc_struct_reg_node_get_type() -> GType;
    pub fn arv_gc_struct_reg_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcSwissKnife
    //=========================================================================
    pub fn arv_gc_swiss_knife_get_type() -> GType;

    //=========================================================================
    // ArvGcSwissKnifeNode
    //=========================================================================
    pub fn arv_gc_swiss_knife_node_get_type() -> GType;
    pub fn arv_gc_swiss_knife_node_new() -> *mut ArvGcNode;

    //=========================================================================
    // ArvGcValueIndexedNode
    //=========================================================================
    pub fn arv_gc_value_indexed_node_get_type() -> GType;
    pub fn arv_gc_value_indexed_node_new() -> *mut ArvGcNode;
    pub fn arv_gc_value_indexed_node_get_index(value_indexed_node: *mut ArvGcValueIndexedNode) -> i64;

    //=========================================================================
    // ArvGvDevice
    //=========================================================================
    pub fn arv_gv_device_get_type() -> GType;
    pub fn arv_gv_device_new(interface_address: *mut gio::GInetAddress, device_address: *mut gio::GInetAddress) -> *mut ArvDevice;
    pub fn arv_gv_device_get_url_regex() -> *mut glib::GRegex;
    pub fn arv_gv_device_auto_packet_size(gv_device: *mut ArvGvDevice) -> c_uint;
    pub fn arv_gv_device_get_device_address(device: *mut ArvGvDevice) -> *mut gio::GSocketAddress;
    pub fn arv_gv_device_get_interface_address(device: *mut ArvGvDevice) -> *mut gio::GSocketAddress;
    pub fn arv_gv_device_get_packet_size(gv_device: *mut ArvGvDevice) -> c_uint;
    pub fn arv_gv_device_get_stream_options(gv_device: *mut ArvGvDevice) -> ArvGvStreamOption;
    pub fn arv_gv_device_get_timestamp_tick_frequency(gv_device: *mut ArvGvDevice) -> u64;
    pub fn arv_gv_device_set_packet_size(gv_device: *mut ArvGvDevice, packet_size: c_int);
    pub fn arv_gv_device_set_stream_options(gv_device: *mut ArvGvDevice, options: ArvGvStreamOption);

    //=========================================================================
    // ArvGvFakeCamera
    //=========================================================================
    pub fn arv_gv_fake_camera_get_type() -> GType;
    pub fn arv_gv_fake_camera_new(interface_name: *const c_char, serial_number: *const c_char) -> *mut ArvGvFakeCamera;
    pub fn arv_gv_fake_camera_new_full(interface_name: *const c_char, serial_number: *const c_char, genicam_filename: *const c_char) -> *mut ArvGvFakeCamera;
    pub fn arv_gv_fake_camera_get_fake_camera(gv_fake_camera: *mut ArvGvFakeCamera) -> *mut ArvFakeCamera;
    pub fn arv_gv_fake_camera_is_running(gv_fake_camera: *mut ArvGvFakeCamera) -> gboolean;

    //=========================================================================
    // ArvGvInterface
    //=========================================================================
    pub fn arv_gv_interface_get_type() -> GType;
    pub fn arv_gv_interface_get_instance() -> *mut ArvInterface;

    //=========================================================================
    // ArvGvStream
    //=========================================================================
    pub fn arv_gv_stream_get_type() -> GType;
    pub fn arv_gv_stream_get_port(gv_stream: *mut ArvGvStream) -> u16;
    pub fn arv_gv_stream_get_statistics(gv_stream: *mut ArvGvStream, n_resent_packets: *mut u64, n_missing_packets: *mut u64);

    //=========================================================================
    // ArvInterface
    //=========================================================================
    pub fn arv_interface_get_type() -> GType;
    pub fn arv_interface_get_device_address(interface: *mut ArvInterface, index: c_uint) -> *const c_char;
    pub fn arv_interface_get_device_id(interface: *mut ArvInterface, index: c_uint) -> *const c_char;
    pub fn arv_interface_get_device_model(interface: *mut ArvInterface, index: c_uint) -> *const c_char;
    pub fn arv_interface_get_device_physical_id(interface: *mut ArvInterface, index: c_uint) -> *const c_char;
    pub fn arv_interface_get_device_protocol(interface: *mut ArvInterface, index: c_uint) -> *const c_char;
    pub fn arv_interface_get_device_serial_nbr(interface: *mut ArvInterface, index: c_uint) -> *const c_char;
    pub fn arv_interface_get_device_vendor(interface: *mut ArvInterface, index: c_uint) -> *const c_char;
    pub fn arv_interface_get_n_devices(interface: *mut ArvInterface) -> c_uint;
    pub fn arv_interface_open_device(interface: *mut ArvInterface, device_id: *const c_char) -> *mut ArvDevice;
    pub fn arv_interface_update_device_list(interface: *mut ArvInterface);

    //=========================================================================
    // ArvStream
    //=========================================================================
    pub fn arv_stream_get_type() -> GType;
    pub fn arv_stream_get_emit_signals(stream: *mut ArvStream) -> gboolean;
    pub fn arv_stream_get_n_buffers(stream: *mut ArvStream, n_input_buffers: *mut c_int, n_output_buffers: *mut c_int);
    pub fn arv_stream_get_statistics(stream: *mut ArvStream, n_completed_buffers: *mut u64, n_failures: *mut u64, n_underruns: *mut u64);
    pub fn arv_stream_pop_buffer(stream: *mut ArvStream) -> *mut ArvBuffer;
    pub fn arv_stream_push_buffer(stream: *mut ArvStream, buffer: *mut ArvBuffer);
    pub fn arv_stream_set_emit_signals(stream: *mut ArvStream, emit_signals: gboolean);
    pub fn arv_stream_start_thread(stream: *mut ArvStream);
    pub fn arv_stream_stop_thread(stream: *mut ArvStream, delete_buffers: gboolean) -> c_uint;
    pub fn arv_stream_timeout_pop_buffer(stream: *mut ArvStream, timeout: u64) -> *mut ArvBuffer;
    pub fn arv_stream_try_pop_buffer(stream: *mut ArvStream) -> *mut ArvBuffer;

    //=========================================================================
    // ArvUvDevice
    //=========================================================================
    pub fn arv_uv_device_get_type() -> GType;
    pub fn arv_uv_device_new(vendor: *const c_char, product: *const c_char, serial_nbr: *const c_char) -> *mut ArvDevice;

    //=========================================================================
    // ArvUvInterface
    //=========================================================================
    pub fn arv_uv_interface_get_type() -> GType;
    pub fn arv_uv_interface_get_instance() -> *mut ArvInterface;

    //=========================================================================
    // ArvUvStream
    //=========================================================================
    pub fn arv_uv_stream_get_type() -> GType;

    //=========================================================================
    // ArvXmlSchema
    //=========================================================================
    pub fn arv_xml_schema_get_type() -> GType;
    pub fn arv_xml_schema_new_from_file(file: *mut gio::GFile) -> *mut ArvXmlSchema;
    pub fn arv_xml_schema_new_from_path(path: *const c_char) -> *mut ArvXmlSchema;
    pub fn arv_xml_schema_validate(schema: *mut ArvXmlSchema, xml: *mut c_void, size: size_t, line: *mut c_int, column: *mut c_int, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // ArvGcFloat
    //=========================================================================
    pub fn arv_gc_float_get_type() -> GType;
    pub fn arv_gc_float_get_inc(gc_float: *mut ArvGcFloat, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_gc_float_get_max(gc_float: *mut ArvGcFloat, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_gc_float_get_min(gc_float: *mut ArvGcFloat, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_gc_float_get_unit(gc_float: *mut ArvGcFloat, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_float_get_value(gc_float: *mut ArvGcFloat, error: *mut *mut glib::GError) -> c_double;
    pub fn arv_gc_float_impose_max(gc_float: *mut ArvGcFloat, maximum: c_double, error: *mut *mut glib::GError);
    pub fn arv_gc_float_impose_min(gc_float: *mut ArvGcFloat, minimum: c_double, error: *mut *mut glib::GError);
    pub fn arv_gc_float_set_value(gc_float: *mut ArvGcFloat, value: c_double, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcInteger
    //=========================================================================
    pub fn arv_gc_integer_get_type() -> GType;
    pub fn arv_gc_integer_get_inc(gc_integer: *mut ArvGcInteger, error: *mut *mut glib::GError) -> i64;
    pub fn arv_gc_integer_get_max(gc_integer: *mut ArvGcInteger, error: *mut *mut glib::GError) -> i64;
    pub fn arv_gc_integer_get_min(gc_integer: *mut ArvGcInteger, error: *mut *mut glib::GError) -> i64;
    pub fn arv_gc_integer_get_unit(gc_integer: *mut ArvGcInteger, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_integer_get_value(gc_integer: *mut ArvGcInteger, error: *mut *mut glib::GError) -> i64;
    pub fn arv_gc_integer_impose_max(gc_integer: *mut ArvGcInteger, maximum: i64, error: *mut *mut glib::GError);
    pub fn arv_gc_integer_impose_min(gc_integer: *mut ArvGcInteger, minimum: i64, error: *mut *mut glib::GError);
    pub fn arv_gc_integer_set_value(gc_integer: *mut ArvGcInteger, value: i64, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcRegister
    //=========================================================================
    pub fn arv_gc_register_get_type() -> GType;
    pub fn arv_gc_register_get(gc_register: *mut ArvGcRegister, buffer: *mut c_void, length: u64, error: *mut *mut glib::GError);
    pub fn arv_gc_register_get_address(gc_register: *mut ArvGcRegister, error: *mut *mut glib::GError) -> u64;
    pub fn arv_gc_register_get_length(gc_register: *mut ArvGcRegister, error: *mut *mut glib::GError) -> u64;
    pub fn arv_gc_register_set(gc_register: *mut ArvGcRegister, buffer: *mut c_void, length: u64, error: *mut *mut glib::GError);

    //=========================================================================
    // ArvGcSelector
    //=========================================================================
    pub fn arv_gc_selector_get_type() -> GType;
    pub fn arv_gc_selector_get_selected_features(gc_selector: *mut ArvGcSelector) -> *const glib::GSList;
    pub fn arv_gc_selector_is_selector(gc_selector: *mut ArvGcSelector) -> gboolean;

    //=========================================================================
    // ArvGcString
    //=========================================================================
    pub fn arv_gc_string_get_type() -> GType;
    pub fn arv_gc_string_get_max_length(gc_string: *mut ArvGcString, error: *mut *mut glib::GError) -> i64;
    pub fn arv_gc_string_get_value(gc_string: *mut ArvGcString, error: *mut *mut glib::GError) -> *const c_char;
    pub fn arv_gc_string_set_value(gc_string: *mut ArvGcString, value: *const c_char, error: *mut *mut glib::GError);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn arv_debug(category: *mut ArvDebugCategory, format: *const c_char, ...);
    pub fn arv_debug_check(category: *mut ArvDebugCategory, level: ArvDebugLevel) -> gboolean;
    pub fn arv_debug_enable(category_selection: *const c_char);
    pub fn arv_debug_shutdown();
    pub fn arv_disable_interface(interface_id: *const c_char);
    pub fn arv_dom_implementation_add_document_type(qualified_name: *const c_char, document_type: GType);
    pub fn arv_dom_implementation_cleanup();
    pub fn arv_dom_implementation_create_document(namespace_uri: *const c_char, qualified_name: *const c_char) -> *mut ArvDomDocument;
    pub fn arv_enable_interface(interface_id: *const c_char);
    pub fn arv_get_device_address(index: c_uint) -> *const c_char;
    pub fn arv_get_device_id(index: c_uint) -> *const c_char;
    pub fn arv_get_device_model(index: c_uint) -> *const c_char;
    pub fn arv_get_device_physical_id(index: c_uint) -> *const c_char;
    pub fn arv_get_device_protocol(index: c_uint) -> *const c_char;
    pub fn arv_get_device_serial_nbr(index: c_uint) -> *const c_char;
    pub fn arv_get_device_vendor(index: c_uint) -> *const c_char;
    pub fn arv_get_interface_id(index: c_uint) -> *const c_char;
    pub fn arv_get_n_devices() -> c_uint;
    pub fn arv_get_n_interfaces() -> c_uint;
    pub fn arv_log(category: *mut ArvDebugCategory, format: *const c_char, ...);
    pub fn arv_make_thread_high_priority(nice_level: c_int) -> gboolean;
    pub fn arv_make_thread_realtime(priority: c_int) -> gboolean;
    pub fn arv_open_device(device_id: *const c_char) -> *mut ArvDevice;
    pub fn arv_set_fake_camera_genicam_filename(filename: *const c_char);
    pub fn arv_shutdown();
    pub fn arv_update_device_list();
    pub fn arv_warning(category: *mut ArvDebugCategory, format: *const c_char, ...);

}
