// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use crate::DomElement;
use crate::DomNode;
use crate::Gc;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;

glib::wrapper! {
	#[doc(alias = "ArvGcNode")]
	pub struct GcNode(Object<ffi::ArvGcNode, ffi::ArvGcNodeClass>) @extends DomElement, DomNode;

	match fn {
		type_ => || ffi::arv_gc_node_get_type(),
	}
}

unsafe impl Send for GcNode {}

pub const NONE_GC_NODE: Option<&GcNode> = None;

/// Trait containing all [`struct@GcNode`] methods.
///
/// # Implementors
///
/// [`GcFeatureNode`][struct@crate::GcFeatureNode], [`GcNode`][struct@crate::GcNode], [`GcPropertyNode`][struct@crate::GcPropertyNode]
pub trait GcNodeExt: 'static {
	/// Retrieves the parent genicam document of `self`.
	///
	/// # Returns
	///
	/// the parent [`Gc`][crate::Gc]
	#[doc(alias = "arv_gc_node_get_genicam")]
	#[doc(alias = "get_genicam")]
	fn genicam(&self) -> Option<Gc>;
}

impl<O: IsA<GcNode>> GcNodeExt for O {
	fn genicam(&self) -> Option<Gc> {
		unsafe { from_glib_none(ffi::arv_gc_node_get_genicam(self.as_ref().to_glib_none().0)) }
	}
}

impl fmt::Display for GcNode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.write_str("GcNode")
	}
}
