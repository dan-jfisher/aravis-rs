// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use aravis_sys;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AcquisitionMode {
	Continuous,
	SingleFrame,
	MultiFrame,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for AcquisitionMode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"AcquisitionMode::{}",
			match *self {
				AcquisitionMode::Continuous => "Continuous",
				AcquisitionMode::SingleFrame => "SingleFrame",
				AcquisitionMode::MultiFrame => "MultiFrame",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for AcquisitionMode {
	type GlibType = aravis_sys::ArvAcquisitionMode;

	fn to_glib(&self) -> aravis_sys::ArvAcquisitionMode {
		match *self {
			AcquisitionMode::Continuous => aravis_sys::ARV_ACQUISITION_MODE_CONTINUOUS,
			AcquisitionMode::SingleFrame => aravis_sys::ARV_ACQUISITION_MODE_SINGLE_FRAME,
			AcquisitionMode::MultiFrame => aravis_sys::ARV_ACQUISITION_MODE_MULTI_FRAME,
			AcquisitionMode::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvAcquisitionMode> for AcquisitionMode {
	fn from_glib(value: aravis_sys::ArvAcquisitionMode) -> Self {
		skip_assert_initialized!();
		match value {
			0 => AcquisitionMode::Continuous,
			1 => AcquisitionMode::SingleFrame,
			2 => AcquisitionMode::MultiFrame,
			value => AcquisitionMode::__Unknown(value),
		}
	}
}

impl StaticType for AcquisitionMode {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_acquisition_mode_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for AcquisitionMode {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for AcquisitionMode {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for AcquisitionMode {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Auto {
	Off,
	Once,
	Continuous,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for Auto {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"Auto::{}",
			match *self {
				Auto::Off => "Off",
				Auto::Once => "Once",
				Auto::Continuous => "Continuous",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for Auto {
	type GlibType = aravis_sys::ArvAuto;

	fn to_glib(&self) -> aravis_sys::ArvAuto {
		match *self {
			Auto::Off => aravis_sys::ARV_AUTO_OFF,
			Auto::Once => aravis_sys::ARV_AUTO_ONCE,
			Auto::Continuous => aravis_sys::ARV_AUTO_CONTINUOUS,
			Auto::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvAuto> for Auto {
	fn from_glib(value: aravis_sys::ArvAuto) -> Self {
		skip_assert_initialized!();
		match value {
			0 => Auto::Off,
			1 => Auto::Once,
			2 => Auto::Continuous,
			value => Auto::__Unknown(value),
		}
	}
}

impl StaticType for Auto {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_auto_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for Auto {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for Auto {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for Auto {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BufferPayloadType {
	Unknown,
	Image,
	Rawdata,
	File,
	ChunkData,
	ExtendedChunkData,
	Jpeg,
	Jpeg2000,
	H264,
	MultizoneImage,
	ImageExtendedChunk,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for BufferPayloadType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"BufferPayloadType::{}",
			match *self {
				BufferPayloadType::Unknown => "Unknown",
				BufferPayloadType::Image => "Image",
				BufferPayloadType::Rawdata => "Rawdata",
				BufferPayloadType::File => "File",
				BufferPayloadType::ChunkData => "ChunkData",
				BufferPayloadType::ExtendedChunkData => "ExtendedChunkData",
				BufferPayloadType::Jpeg => "Jpeg",
				BufferPayloadType::Jpeg2000 => "Jpeg2000",
				BufferPayloadType::H264 => "H264",
				BufferPayloadType::MultizoneImage => "MultizoneImage",
				BufferPayloadType::ImageExtendedChunk => "ImageExtendedChunk",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for BufferPayloadType {
	type GlibType = aravis_sys::ArvBufferPayloadType;

	fn to_glib(&self) -> aravis_sys::ArvBufferPayloadType {
		match *self {
			BufferPayloadType::Unknown => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN,
			BufferPayloadType::Image => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_IMAGE,
			BufferPayloadType::Rawdata => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_RAWDATA,
			BufferPayloadType::File => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_FILE,
			BufferPayloadType::ChunkData => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA,
			BufferPayloadType::ExtendedChunkData => {
				aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA
			}
			BufferPayloadType::Jpeg => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_JPEG,
			BufferPayloadType::Jpeg2000 => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_JPEG2000,
			BufferPayloadType::H264 => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_H264,
			BufferPayloadType::MultizoneImage => {
				aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE
			}
			BufferPayloadType::ImageExtendedChunk => {
				aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK
			}
			BufferPayloadType::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvBufferPayloadType> for BufferPayloadType {
	fn from_glib(value: aravis_sys::ArvBufferPayloadType) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => BufferPayloadType::Unknown,
			1 => BufferPayloadType::Image,
			2 => BufferPayloadType::Rawdata,
			3 => BufferPayloadType::File,
			4 => BufferPayloadType::ChunkData,
			5 => BufferPayloadType::ExtendedChunkData,
			6 => BufferPayloadType::Jpeg,
			7 => BufferPayloadType::Jpeg2000,
			8 => BufferPayloadType::H264,
			9 => BufferPayloadType::MultizoneImage,
			16385 => BufferPayloadType::ImageExtendedChunk,
			value => BufferPayloadType::__Unknown(value),
		}
	}
}

impl StaticType for BufferPayloadType {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_buffer_payload_type_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for BufferPayloadType {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for BufferPayloadType {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for BufferPayloadType {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BufferStatus {
	Unknown,
	Success,
	Cleared,
	Timeout,
	MissingPackets,
	WrongPacketId,
	SizeMismatch,
	Filling,
	Aborted,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for BufferStatus {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"BufferStatus::{}",
			match *self {
				BufferStatus::Unknown => "Unknown",
				BufferStatus::Success => "Success",
				BufferStatus::Cleared => "Cleared",
				BufferStatus::Timeout => "Timeout",
				BufferStatus::MissingPackets => "MissingPackets",
				BufferStatus::WrongPacketId => "WrongPacketId",
				BufferStatus::SizeMismatch => "SizeMismatch",
				BufferStatus::Filling => "Filling",
				BufferStatus::Aborted => "Aborted",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for BufferStatus {
	type GlibType = aravis_sys::ArvBufferStatus;

	fn to_glib(&self) -> aravis_sys::ArvBufferStatus {
		match *self {
			BufferStatus::Unknown => aravis_sys::ARV_BUFFER_STATUS_UNKNOWN,
			BufferStatus::Success => aravis_sys::ARV_BUFFER_STATUS_SUCCESS,
			BufferStatus::Cleared => aravis_sys::ARV_BUFFER_STATUS_CLEARED,
			BufferStatus::Timeout => aravis_sys::ARV_BUFFER_STATUS_TIMEOUT,
			BufferStatus::MissingPackets => aravis_sys::ARV_BUFFER_STATUS_MISSING_PACKETS,
			BufferStatus::WrongPacketId => aravis_sys::ARV_BUFFER_STATUS_WRONG_PACKET_ID,
			BufferStatus::SizeMismatch => aravis_sys::ARV_BUFFER_STATUS_SIZE_MISMATCH,
			BufferStatus::Filling => aravis_sys::ARV_BUFFER_STATUS_FILLING,
			BufferStatus::Aborted => aravis_sys::ARV_BUFFER_STATUS_ABORTED,
			BufferStatus::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvBufferStatus> for BufferStatus {
	fn from_glib(value: aravis_sys::ArvBufferStatus) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => BufferStatus::Unknown,
			0 => BufferStatus::Success,
			1 => BufferStatus::Cleared,
			2 => BufferStatus::Timeout,
			3 => BufferStatus::MissingPackets,
			4 => BufferStatus::WrongPacketId,
			5 => BufferStatus::SizeMismatch,
			6 => BufferStatus::Filling,
			7 => BufferStatus::Aborted,
			value => BufferStatus::__Unknown(value),
		}
	}
}

impl StaticType for BufferStatus {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_buffer_status_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for BufferStatus {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for BufferStatus {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for BufferStatus {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ChunkParserError {
	InvalidFeatureType,
	BufferNotFound,
	ChunkNotFound,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for ChunkParserError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"ChunkParserError::{}",
			match *self {
				ChunkParserError::InvalidFeatureType => "InvalidFeatureType",
				ChunkParserError::BufferNotFound => "BufferNotFound",
				ChunkParserError::ChunkNotFound => "ChunkNotFound",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for ChunkParserError {
	type GlibType = aravis_sys::ArvChunkParserError;

	fn to_glib(&self) -> aravis_sys::ArvChunkParserError {
		match *self {
			ChunkParserError::InvalidFeatureType => {
				aravis_sys::ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE
			}
			ChunkParserError::BufferNotFound => aravis_sys::ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND,
			ChunkParserError::ChunkNotFound => aravis_sys::ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND,
			ChunkParserError::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvChunkParserError> for ChunkParserError {
	fn from_glib(value: aravis_sys::ArvChunkParserError) -> Self {
		skip_assert_initialized!();
		match value {
			0 => ChunkParserError::InvalidFeatureType,
			1 => ChunkParserError::BufferNotFound,
			2 => ChunkParserError::ChunkNotFound,
			value => ChunkParserError::__Unknown(value),
		}
	}
}

impl ErrorDomain for ChunkParserError {
	fn domain() -> Quark {
		skip_assert_initialized!();

		unsafe { from_glib(aravis_sys::arv_chunk_parser_error_quark()) }
	}

	fn code(self) -> i32 {
		self.to_glib()
	}

	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match code {
			0 => Some(ChunkParserError::InvalidFeatureType),
			1 => Some(ChunkParserError::BufferNotFound),
			2 => Some(ChunkParserError::ChunkNotFound),
			value => Some(ChunkParserError::__Unknown(value)),
		}
	}
}

impl StaticType for ChunkParserError {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_chunk_parser_error_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for ChunkParserError {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for ChunkParserError {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for ChunkParserError {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DeviceError {
	WrongFeature,
	FeatureNotFound,
	NotConnected,
	ProtocolError,
	TransferError,
	Timeout,
	NotFound,
	InvalidParameter,
	GenicamNotFound,
	NoStreamChannel,
	NotController,
	Unknown,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for DeviceError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"DeviceError::{}",
			match *self {
				DeviceError::WrongFeature => "WrongFeature",
				DeviceError::FeatureNotFound => "FeatureNotFound",
				DeviceError::NotConnected => "NotConnected",
				DeviceError::ProtocolError => "ProtocolError",
				DeviceError::TransferError => "TransferError",
				DeviceError::Timeout => "Timeout",
				DeviceError::NotFound => "NotFound",
				DeviceError::InvalidParameter => "InvalidParameter",
				DeviceError::GenicamNotFound => "GenicamNotFound",
				DeviceError::NoStreamChannel => "NoStreamChannel",
				DeviceError::NotController => "NotController",
				DeviceError::Unknown => "Unknown",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for DeviceError {
	type GlibType = aravis_sys::ArvDeviceError;

	fn to_glib(&self) -> aravis_sys::ArvDeviceError {
		match *self {
			DeviceError::WrongFeature => aravis_sys::ARV_DEVICE_ERROR_WRONG_FEATURE,
			DeviceError::FeatureNotFound => aravis_sys::ARV_DEVICE_ERROR_FEATURE_NOT_FOUND,
			DeviceError::NotConnected => aravis_sys::ARV_DEVICE_ERROR_NOT_CONNECTED,
			DeviceError::ProtocolError => aravis_sys::ARV_DEVICE_ERROR_PROTOCOL_ERROR,
			DeviceError::TransferError => aravis_sys::ARV_DEVICE_ERROR_TRANSFER_ERROR,
			DeviceError::Timeout => aravis_sys::ARV_DEVICE_ERROR_TIMEOUT,
			DeviceError::NotFound => aravis_sys::ARV_DEVICE_ERROR_NOT_FOUND,
			DeviceError::InvalidParameter => aravis_sys::ARV_DEVICE_ERROR_INVALID_PARAMETER,
			DeviceError::GenicamNotFound => aravis_sys::ARV_DEVICE_ERROR_GENICAM_NOT_FOUND,
			DeviceError::NoStreamChannel => aravis_sys::ARV_DEVICE_ERROR_NO_STREAM_CHANNEL,
			DeviceError::NotController => aravis_sys::ARV_DEVICE_ERROR_NOT_CONTROLLER,
			DeviceError::Unknown => aravis_sys::ARV_DEVICE_ERROR_UNKNOWN,
			DeviceError::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvDeviceError> for DeviceError {
	fn from_glib(value: aravis_sys::ArvDeviceError) -> Self {
		skip_assert_initialized!();
		match value {
			0 => DeviceError::WrongFeature,
			1 => DeviceError::FeatureNotFound,
			2 => DeviceError::NotConnected,
			3 => DeviceError::ProtocolError,
			4 => DeviceError::TransferError,
			5 => DeviceError::Timeout,
			6 => DeviceError::NotFound,
			7 => DeviceError::InvalidParameter,
			8 => DeviceError::GenicamNotFound,
			9 => DeviceError::NoStreamChannel,
			10 => DeviceError::NotController,
			11 => DeviceError::Unknown,
			value => DeviceError::__Unknown(value),
		}
	}
}

impl ErrorDomain for DeviceError {
	fn domain() -> Quark {
		skip_assert_initialized!();

		unsafe { from_glib(aravis_sys::arv_device_error_quark()) }
	}

	fn code(self) -> i32 {
		self.to_glib()
	}

	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match code {
			0 => Some(DeviceError::WrongFeature),
			1 => Some(DeviceError::FeatureNotFound),
			2 => Some(DeviceError::NotConnected),
			3 => Some(DeviceError::ProtocolError),
			4 => Some(DeviceError::TransferError),
			5 => Some(DeviceError::Timeout),
			6 => Some(DeviceError::NotFound),
			7 => Some(DeviceError::InvalidParameter),
			8 => Some(DeviceError::GenicamNotFound),
			9 => Some(DeviceError::NoStreamChannel),
			10 => Some(DeviceError::NotController),
			11 => Some(DeviceError::Unknown),
			value => Some(DeviceError::__Unknown(value)),
		}
	}
}

impl StaticType for DeviceError {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_device_error_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for DeviceError {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for DeviceError {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for DeviceError {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DomNodeType {
	ElementNode,
	AttributeNode,
	TextNode,
	CdataSectionNode,
	EntityReferenceNode,
	EntityNode,
	ProcessingInstructionNode,
	CommentNode,
	DocumentNode,
	DocumentTypeNode,
	DocumentFragmentNode,
	NotationNode,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for DomNodeType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"DomNodeType::{}",
			match *self {
				DomNodeType::ElementNode => "ElementNode",
				DomNodeType::AttributeNode => "AttributeNode",
				DomNodeType::TextNode => "TextNode",
				DomNodeType::CdataSectionNode => "CdataSectionNode",
				DomNodeType::EntityReferenceNode => "EntityReferenceNode",
				DomNodeType::EntityNode => "EntityNode",
				DomNodeType::ProcessingInstructionNode => "ProcessingInstructionNode",
				DomNodeType::CommentNode => "CommentNode",
				DomNodeType::DocumentNode => "DocumentNode",
				DomNodeType::DocumentTypeNode => "DocumentTypeNode",
				DomNodeType::DocumentFragmentNode => "DocumentFragmentNode",
				DomNodeType::NotationNode => "NotationNode",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for DomNodeType {
	type GlibType = aravis_sys::ArvDomNodeType;

	fn to_glib(&self) -> aravis_sys::ArvDomNodeType {
		match *self {
			DomNodeType::ElementNode => aravis_sys::ARV_DOM_NODE_TYPE_ELEMENT_NODE,
			DomNodeType::AttributeNode => aravis_sys::ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE,
			DomNodeType::TextNode => aravis_sys::ARV_DOM_NODE_TYPE_TEXT_NODE,
			DomNodeType::CdataSectionNode => aravis_sys::ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE,
			DomNodeType::EntityReferenceNode => aravis_sys::ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE,
			DomNodeType::EntityNode => aravis_sys::ARV_DOM_NODE_TYPE_ENTITY_NODE,
			DomNodeType::ProcessingInstructionNode => {
				aravis_sys::ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE
			}
			DomNodeType::CommentNode => aravis_sys::ARV_DOM_NODE_TYPE_COMMENT_NODE,
			DomNodeType::DocumentNode => aravis_sys::ARV_DOM_NODE_TYPE_DOCUMENT_NODE,
			DomNodeType::DocumentTypeNode => aravis_sys::ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE,
			DomNodeType::DocumentFragmentNode => {
				aravis_sys::ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE
			}
			DomNodeType::NotationNode => aravis_sys::ARV_DOM_NODE_TYPE_NOTATION_NODE,
			DomNodeType::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvDomNodeType> for DomNodeType {
	fn from_glib(value: aravis_sys::ArvDomNodeType) -> Self {
		skip_assert_initialized!();
		match value {
			1 => DomNodeType::ElementNode,
			2 => DomNodeType::AttributeNode,
			3 => DomNodeType::TextNode,
			4 => DomNodeType::CdataSectionNode,
			5 => DomNodeType::EntityReferenceNode,
			6 => DomNodeType::EntityNode,
			7 => DomNodeType::ProcessingInstructionNode,
			8 => DomNodeType::CommentNode,
			9 => DomNodeType::DocumentNode,
			10 => DomNodeType::DocumentTypeNode,
			11 => DomNodeType::DocumentFragmentNode,
			12 => DomNodeType::NotationNode,
			value => DomNodeType::__Unknown(value),
		}
	}
}

impl StaticType for DomNodeType {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_dom_node_type_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for DomNodeType {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for DomNodeType {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for DomNodeType {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Specifies access mode for feature nodes and registers.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcAccessMode {
	Undefined,
	Ro,
	Wo,
	Rw,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcAccessMode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcAccessMode::{}",
			match *self {
				GcAccessMode::Undefined => "Undefined",
				GcAccessMode::Ro => "Ro",
				GcAccessMode::Wo => "Wo",
				GcAccessMode::Rw => "Rw",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcAccessMode {
	type GlibType = aravis_sys::ArvGcAccessMode;

	fn to_glib(&self) -> aravis_sys::ArvGcAccessMode {
		match *self {
			GcAccessMode::Undefined => aravis_sys::ARV_GC_ACCESS_MODE_UNDEFINED,
			GcAccessMode::Ro => aravis_sys::ARV_GC_ACCESS_MODE_RO,
			GcAccessMode::Wo => aravis_sys::ARV_GC_ACCESS_MODE_WO,
			GcAccessMode::Rw => aravis_sys::ARV_GC_ACCESS_MODE_RW,
			GcAccessMode::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcAccessMode> for GcAccessMode {
	fn from_glib(value: aravis_sys::ArvGcAccessMode) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcAccessMode::Undefined,
			0 => GcAccessMode::Ro,
			1 => GcAccessMode::Wo,
			2 => GcAccessMode::Rw,
			value => GcAccessMode::__Unknown(value),
		}
	}
}

impl StaticType for GcAccessMode {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_access_mode_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcAccessMode {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcAccessMode {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcAccessMode {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Specifies caching mode for register values.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcCachable {
	Undefined,
	NoCache,
	WriteThrough,
	WriteAround,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcCachable {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcCachable::{}",
			match *self {
				GcCachable::Undefined => "Undefined",
				GcCachable::NoCache => "NoCache",
				GcCachable::WriteThrough => "WriteThrough",
				GcCachable::WriteAround => "WriteAround",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcCachable {
	type GlibType = aravis_sys::ArvGcCachable;

	fn to_glib(&self) -> aravis_sys::ArvGcCachable {
		match *self {
			GcCachable::Undefined => aravis_sys::ARV_GC_CACHABLE_UNDEFINED,
			GcCachable::NoCache => aravis_sys::ARV_GC_CACHABLE_NO_CACHE,
			GcCachable::WriteThrough => aravis_sys::ARV_GC_CACHABLE_WRITE_THROUGH,
			GcCachable::WriteAround => aravis_sys::ARV_GC_CACHABLE_WRITE_AROUND,
			GcCachable::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcCachable> for GcCachable {
	fn from_glib(value: aravis_sys::ArvGcCachable) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcCachable::Undefined,
			0 => GcCachable::NoCache,
			1 => GcCachable::WriteThrough,
			2 => GcCachable::WriteAround,
			value => GcCachable::__Unknown(value),
		}
	}
}

impl StaticType for GcCachable {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_cachable_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcCachable {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcCachable {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcCachable {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Number display notations for showing numbers in user interfaces.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcDisplayNotation {
	Undefined,
	Automatic,
	Fixed,
	Scientific,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcDisplayNotation {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcDisplayNotation::{}",
			match *self {
				GcDisplayNotation::Undefined => "Undefined",
				GcDisplayNotation::Automatic => "Automatic",
				GcDisplayNotation::Fixed => "Fixed",
				GcDisplayNotation::Scientific => "Scientific",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcDisplayNotation {
	type GlibType = aravis_sys::ArvGcDisplayNotation;

	fn to_glib(&self) -> aravis_sys::ArvGcDisplayNotation {
		match *self {
			GcDisplayNotation::Undefined => aravis_sys::ARV_GC_DISPLAY_NOTATION_UNDEFINED,
			GcDisplayNotation::Automatic => aravis_sys::ARV_GC_DISPLAY_NOTATION_AUTOMATIC,
			GcDisplayNotation::Fixed => aravis_sys::ARV_GC_DISPLAY_NOTATION_FIXED,
			GcDisplayNotation::Scientific => aravis_sys::ARV_GC_DISPLAY_NOTATION_SCIENTIFIC,
			GcDisplayNotation::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcDisplayNotation> for GcDisplayNotation {
	fn from_glib(value: aravis_sys::ArvGcDisplayNotation) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcDisplayNotation::Undefined,
			0 => GcDisplayNotation::Automatic,
			1 => GcDisplayNotation::Fixed,
			2 => GcDisplayNotation::Scientific,
			value => GcDisplayNotation::__Unknown(value),
		}
	}
}

impl StaticType for GcDisplayNotation {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_display_notation_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcDisplayNotation {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcDisplayNotation {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcDisplayNotation {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcError {
	PropertyNotDefined,
	PvalueNotDefined,
	InvalidPvalue,
	EmptyEnumeration,
	OutOfRange,
	NoDeviceSet,
	NoEventImplementation,
	NodeNotFound,
	EnumEntryNotFound,
	InvalidLength,
	ReadOnly,
	SetFromStringUndefined,
	GetAsStringUndefined,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcError::{}",
			match *self {
				GcError::PropertyNotDefined => "PropertyNotDefined",
				GcError::PvalueNotDefined => "PvalueNotDefined",
				GcError::InvalidPvalue => "InvalidPvalue",
				GcError::EmptyEnumeration => "EmptyEnumeration",
				GcError::OutOfRange => "OutOfRange",
				GcError::NoDeviceSet => "NoDeviceSet",
				GcError::NoEventImplementation => "NoEventImplementation",
				GcError::NodeNotFound => "NodeNotFound",
				GcError::EnumEntryNotFound => "EnumEntryNotFound",
				GcError::InvalidLength => "InvalidLength",
				GcError::ReadOnly => "ReadOnly",
				GcError::SetFromStringUndefined => "SetFromStringUndefined",
				GcError::GetAsStringUndefined => "GetAsStringUndefined",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcError {
	type GlibType = aravis_sys::ArvGcError;

	fn to_glib(&self) -> aravis_sys::ArvGcError {
		match *self {
			GcError::PropertyNotDefined => aravis_sys::ARV_GC_ERROR_PROPERTY_NOT_DEFINED,
			GcError::PvalueNotDefined => aravis_sys::ARV_GC_ERROR_PVALUE_NOT_DEFINED,
			GcError::InvalidPvalue => aravis_sys::ARV_GC_ERROR_INVALID_PVALUE,
			GcError::EmptyEnumeration => aravis_sys::ARV_GC_ERROR_EMPTY_ENUMERATION,
			GcError::OutOfRange => aravis_sys::ARV_GC_ERROR_OUT_OF_RANGE,
			GcError::NoDeviceSet => aravis_sys::ARV_GC_ERROR_NO_DEVICE_SET,
			GcError::NoEventImplementation => aravis_sys::ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION,
			GcError::NodeNotFound => aravis_sys::ARV_GC_ERROR_NODE_NOT_FOUND,
			GcError::EnumEntryNotFound => aravis_sys::ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND,
			GcError::InvalidLength => aravis_sys::ARV_GC_ERROR_INVALID_LENGTH,
			GcError::ReadOnly => aravis_sys::ARV_GC_ERROR_READ_ONLY,
			GcError::SetFromStringUndefined => aravis_sys::ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED,
			GcError::GetAsStringUndefined => aravis_sys::ARV_GC_ERROR_GET_AS_STRING_UNDEFINED,
			GcError::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcError> for GcError {
	fn from_glib(value: aravis_sys::ArvGcError) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GcError::PropertyNotDefined,
			1 => GcError::PvalueNotDefined,
			2 => GcError::InvalidPvalue,
			3 => GcError::EmptyEnumeration,
			4 => GcError::OutOfRange,
			5 => GcError::NoDeviceSet,
			6 => GcError::NoEventImplementation,
			7 => GcError::NodeNotFound,
			8 => GcError::EnumEntryNotFound,
			9 => GcError::InvalidLength,
			10 => GcError::ReadOnly,
			11 => GcError::SetFromStringUndefined,
			12 => GcError::GetAsStringUndefined,
			value => GcError::__Unknown(value),
		}
	}
}

impl ErrorDomain for GcError {
	fn domain() -> Quark {
		skip_assert_initialized!();

		unsafe { from_glib(aravis_sys::arv_gc_error_quark()) }
	}

	fn code(self) -> i32 {
		self.to_glib()
	}

	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match code {
			0 => Some(GcError::PropertyNotDefined),
			1 => Some(GcError::PvalueNotDefined),
			2 => Some(GcError::InvalidPvalue),
			3 => Some(GcError::EmptyEnumeration),
			4 => Some(GcError::OutOfRange),
			5 => Some(GcError::NoDeviceSet),
			6 => Some(GcError::NoEventImplementation),
			7 => Some(GcError::NodeNotFound),
			8 => Some(GcError::EnumEntryNotFound),
			9 => Some(GcError::InvalidLength),
			10 => Some(GcError::ReadOnly),
			11 => Some(GcError::SetFromStringUndefined),
			12 => Some(GcError::GetAsStringUndefined),
			value => Some(GcError::__Unknown(value)),
		}
	}
}

impl StaticType for GcError {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_error_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcError {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcError {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcError {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Describes relationship between TO and FROM variables in Converter feature nodes.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcIsLinear {
	Undefined,
	No,
	Yes,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcIsLinear {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcIsLinear::{}",
			match *self {
				GcIsLinear::Undefined => "Undefined",
				GcIsLinear::No => "No",
				GcIsLinear::Yes => "Yes",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcIsLinear {
	type GlibType = aravis_sys::ArvGcIsLinear;

	fn to_glib(&self) -> aravis_sys::ArvGcIsLinear {
		match *self {
			GcIsLinear::Undefined => aravis_sys::ARV_GC_IS_LINEAR_UNDEFINED,
			GcIsLinear::No => aravis_sys::ARV_GC_IS_LINEAR_NO,
			GcIsLinear::Yes => aravis_sys::ARV_GC_IS_LINEAR_YES,
			GcIsLinear::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcIsLinear> for GcIsLinear {
	fn from_glib(value: aravis_sys::ArvGcIsLinear) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcIsLinear::Undefined,
			0 => GcIsLinear::No,
			1 => GcIsLinear::Yes,
			value => GcIsLinear::__Unknown(value),
		}
	}
}

impl StaticType for GcIsLinear {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_is_linear_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcIsLinear {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcIsLinear {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcIsLinear {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Specifies feature node or register name space type. Standard name space features are listed in
/// Genicam materials. Any other vendor-specific features should use custom name space type.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcNameSpace {
	Undefined,
	Standard,
	Custom,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcNameSpace {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcNameSpace::{}",
			match *self {
				GcNameSpace::Undefined => "Undefined",
				GcNameSpace::Standard => "Standard",
				GcNameSpace::Custom => "Custom",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcNameSpace {
	type GlibType = aravis_sys::ArvGcNameSpace;

	fn to_glib(&self) -> aravis_sys::ArvGcNameSpace {
		match *self {
			GcNameSpace::Undefined => aravis_sys::ARV_GC_NAME_SPACE_UNDEFINED,
			GcNameSpace::Standard => aravis_sys::ARV_GC_NAME_SPACE_STANDARD,
			GcNameSpace::Custom => aravis_sys::ARV_GC_NAME_SPACE_CUSTOM,
			GcNameSpace::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcNameSpace> for GcNameSpace {
	fn from_glib(value: aravis_sys::ArvGcNameSpace) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcNameSpace::Undefined,
			0 => GcNameSpace::Standard,
			1 => GcNameSpace::Custom,
			value => GcNameSpace::__Unknown(value),
		}
	}
}

impl StaticType for GcNameSpace {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_name_space_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcNameSpace {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcNameSpace {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcNameSpace {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcPropertyNodeType {
	Unknown,
	Value,
	Address,
	Description,
	Visibility,
	Tooltip,
	DisplayName,
	Minimum,
	Maximum,
	Slope,
	Increment,
	IsLinear,
	Representation,
	DisplayNotation,
	DisplayPrecision,
	Unit,
	OnValue,
	OffValue,
	Length,
	Formula,
	FormulaTo,
	FormulaFrom,
	Expression,
	Constant,
	AccessMode,
	ImposedAccessMode,
	Cachable,
	PollingTime,
	Endianness,
	Sign,
	Lsb,
	Msb,
	Bit,
	CommandValue,
	ChunkId,
	EventId,
	ValueIndexed,
	ValueDefault,
	PUnknonw,
	PFeature,
	PValue,
	PAddress,
	PIsImplemented,
	PIsLocked,
	PIsAvailable,
	PSelected,
	PMinimum,
	PMaximum,
	PIncrement,
	PIndex,
	PLength,
	PPort,
	PVariable,
	PInvalidator,
	PCommandValue,
	PValueIndexed,
	PValueDefault,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcPropertyNodeType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcPropertyNodeType::{}",
			match *self {
				GcPropertyNodeType::Unknown => "Unknown",
				GcPropertyNodeType::Value => "Value",
				GcPropertyNodeType::Address => "Address",
				GcPropertyNodeType::Description => "Description",
				GcPropertyNodeType::Visibility => "Visibility",
				GcPropertyNodeType::Tooltip => "Tooltip",
				GcPropertyNodeType::DisplayName => "DisplayName",
				GcPropertyNodeType::Minimum => "Minimum",
				GcPropertyNodeType::Maximum => "Maximum",
				GcPropertyNodeType::Slope => "Slope",
				GcPropertyNodeType::Increment => "Increment",
				GcPropertyNodeType::IsLinear => "IsLinear",
				GcPropertyNodeType::Representation => "Representation",
				GcPropertyNodeType::DisplayNotation => "DisplayNotation",
				GcPropertyNodeType::DisplayPrecision => "DisplayPrecision",
				GcPropertyNodeType::Unit => "Unit",
				GcPropertyNodeType::OnValue => "OnValue",
				GcPropertyNodeType::OffValue => "OffValue",
				GcPropertyNodeType::Length => "Length",
				GcPropertyNodeType::Formula => "Formula",
				GcPropertyNodeType::FormulaTo => "FormulaTo",
				GcPropertyNodeType::FormulaFrom => "FormulaFrom",
				GcPropertyNodeType::Expression => "Expression",
				GcPropertyNodeType::Constant => "Constant",
				GcPropertyNodeType::AccessMode => "AccessMode",
				GcPropertyNodeType::ImposedAccessMode => "ImposedAccessMode",
				GcPropertyNodeType::Cachable => "Cachable",
				GcPropertyNodeType::PollingTime => "PollingTime",
				GcPropertyNodeType::Endianness => "Endianness",
				GcPropertyNodeType::Sign => "Sign",
				GcPropertyNodeType::Lsb => "Lsb",
				GcPropertyNodeType::Msb => "Msb",
				GcPropertyNodeType::Bit => "Bit",
				GcPropertyNodeType::CommandValue => "CommandValue",
				GcPropertyNodeType::ChunkId => "ChunkId",
				GcPropertyNodeType::EventId => "EventId",
				GcPropertyNodeType::ValueIndexed => "ValueIndexed",
				GcPropertyNodeType::ValueDefault => "ValueDefault",
				GcPropertyNodeType::PUnknonw => "PUnknonw",
				GcPropertyNodeType::PFeature => "PFeature",
				GcPropertyNodeType::PValue => "PValue",
				GcPropertyNodeType::PAddress => "PAddress",
				GcPropertyNodeType::PIsImplemented => "PIsImplemented",
				GcPropertyNodeType::PIsLocked => "PIsLocked",
				GcPropertyNodeType::PIsAvailable => "PIsAvailable",
				GcPropertyNodeType::PSelected => "PSelected",
				GcPropertyNodeType::PMinimum => "PMinimum",
				GcPropertyNodeType::PMaximum => "PMaximum",
				GcPropertyNodeType::PIncrement => "PIncrement",
				GcPropertyNodeType::PIndex => "PIndex",
				GcPropertyNodeType::PLength => "PLength",
				GcPropertyNodeType::PPort => "PPort",
				GcPropertyNodeType::PVariable => "PVariable",
				GcPropertyNodeType::PInvalidator => "PInvalidator",
				GcPropertyNodeType::PCommandValue => "PCommandValue",
				GcPropertyNodeType::PValueIndexed => "PValueIndexed",
				GcPropertyNodeType::PValueDefault => "PValueDefault",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcPropertyNodeType {
	type GlibType = aravis_sys::ArvGcPropertyNodeType;

	fn to_glib(&self) -> aravis_sys::ArvGcPropertyNodeType {
		match *self {
			GcPropertyNodeType::Unknown => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN,
			GcPropertyNodeType::Value => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VALUE,
			GcPropertyNodeType::Address => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ADDRESS,
			GcPropertyNodeType::Description => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION,
			GcPropertyNodeType::Visibility => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY,
			GcPropertyNodeType::Tooltip => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP,
			GcPropertyNodeType::DisplayName => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME,
			GcPropertyNodeType::Minimum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_MINIMUM,
			GcPropertyNodeType::Maximum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM,
			GcPropertyNodeType::Slope => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_SLOPE,
			GcPropertyNodeType::Increment => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_INCREMENT,
			GcPropertyNodeType::IsLinear => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR,
			GcPropertyNodeType::Representation => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION
			}
			GcPropertyNodeType::DisplayNotation => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION
			}
			GcPropertyNodeType::DisplayPrecision => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION
			}
			GcPropertyNodeType::Unit => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_UNIT,
			GcPropertyNodeType::OnValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE,
			GcPropertyNodeType::OffValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE,
			GcPropertyNodeType::Length => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_LENGTH,
			GcPropertyNodeType::Formula => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_FORMULA,
			GcPropertyNodeType::FormulaTo => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO,
			GcPropertyNodeType::FormulaFrom => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM,
			GcPropertyNodeType::Expression => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION,
			GcPropertyNodeType::Constant => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_CONSTANT,
			GcPropertyNodeType::AccessMode => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE,
			GcPropertyNodeType::ImposedAccessMode => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE
			}
			GcPropertyNodeType::Cachable => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_CACHABLE,
			GcPropertyNodeType::PollingTime => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME,
			GcPropertyNodeType::Endianness => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS,
			GcPropertyNodeType::Sign => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_SIGN,
			GcPropertyNodeType::Lsb => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_LSB,
			GcPropertyNodeType::Msb => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_MSB,
			GcPropertyNodeType::Bit => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_BIT,
			GcPropertyNodeType::CommandValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE,
			GcPropertyNodeType::ChunkId => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID,
			GcPropertyNodeType::EventId => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID,
			GcPropertyNodeType::ValueIndexed => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED,
			GcPropertyNodeType::ValueDefault => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT,
			GcPropertyNodeType::PUnknonw => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW,
			GcPropertyNodeType::PFeature => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE,
			GcPropertyNodeType::PValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE,
			GcPropertyNodeType::PAddress => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS,
			GcPropertyNodeType::PIsImplemented => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED
			}
			GcPropertyNodeType::PIsLocked => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED,
			GcPropertyNodeType::PIsAvailable => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE
			}
			GcPropertyNodeType::PSelected => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED,
			GcPropertyNodeType::PMinimum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM,
			GcPropertyNodeType::PMaximum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM,
			GcPropertyNodeType::PIncrement => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT,
			GcPropertyNodeType::PIndex => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_INDEX,
			GcPropertyNodeType::PLength => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH,
			GcPropertyNodeType::PPort => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_PORT,
			GcPropertyNodeType::PVariable => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE,
			GcPropertyNodeType::PInvalidator => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR,
			GcPropertyNodeType::PCommandValue => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE
			}
			GcPropertyNodeType::PValueIndexed => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED
			}
			GcPropertyNodeType::PValueDefault => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT
			}
			GcPropertyNodeType::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcPropertyNodeType> for GcPropertyNodeType {
	fn from_glib(value: aravis_sys::ArvGcPropertyNodeType) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GcPropertyNodeType::Unknown,
			1 => GcPropertyNodeType::Value,
			2 => GcPropertyNodeType::Address,
			3 => GcPropertyNodeType::Description,
			4 => GcPropertyNodeType::Visibility,
			5 => GcPropertyNodeType::Tooltip,
			6 => GcPropertyNodeType::DisplayName,
			7 => GcPropertyNodeType::Minimum,
			8 => GcPropertyNodeType::Maximum,
			9 => GcPropertyNodeType::Slope,
			10 => GcPropertyNodeType::Increment,
			11 => GcPropertyNodeType::IsLinear,
			12 => GcPropertyNodeType::Representation,
			13 => GcPropertyNodeType::DisplayNotation,
			14 => GcPropertyNodeType::DisplayPrecision,
			15 => GcPropertyNodeType::Unit,
			16 => GcPropertyNodeType::OnValue,
			17 => GcPropertyNodeType::OffValue,
			18 => GcPropertyNodeType::Length,
			19 => GcPropertyNodeType::Formula,
			20 => GcPropertyNodeType::FormulaTo,
			21 => GcPropertyNodeType::FormulaFrom,
			22 => GcPropertyNodeType::Expression,
			23 => GcPropertyNodeType::Constant,
			24 => GcPropertyNodeType::AccessMode,
			25 => GcPropertyNodeType::ImposedAccessMode,
			26 => GcPropertyNodeType::Cachable,
			27 => GcPropertyNodeType::PollingTime,
			28 => GcPropertyNodeType::Endianness,
			29 => GcPropertyNodeType::Sign,
			30 => GcPropertyNodeType::Lsb,
			31 => GcPropertyNodeType::Msb,
			32 => GcPropertyNodeType::Bit,
			33 => GcPropertyNodeType::CommandValue,
			34 => GcPropertyNodeType::ChunkId,
			35 => GcPropertyNodeType::EventId,
			36 => GcPropertyNodeType::ValueIndexed,
			37 => GcPropertyNodeType::ValueDefault,
			1000 => GcPropertyNodeType::PUnknonw,
			1001 => GcPropertyNodeType::PFeature,
			1002 => GcPropertyNodeType::PValue,
			1003 => GcPropertyNodeType::PAddress,
			1004 => GcPropertyNodeType::PIsImplemented,
			1005 => GcPropertyNodeType::PIsLocked,
			1006 => GcPropertyNodeType::PIsAvailable,
			1007 => GcPropertyNodeType::PSelected,
			1008 => GcPropertyNodeType::PMinimum,
			1009 => GcPropertyNodeType::PMaximum,
			1010 => GcPropertyNodeType::PIncrement,
			1011 => GcPropertyNodeType::PIndex,
			1012 => GcPropertyNodeType::PLength,
			1013 => GcPropertyNodeType::PPort,
			1014 => GcPropertyNodeType::PVariable,
			1015 => GcPropertyNodeType::PInvalidator,
			1016 => GcPropertyNodeType::PCommandValue,
			1017 => GcPropertyNodeType::PValueIndexed,
			1018 => GcPropertyNodeType::PValueDefault,
			value => GcPropertyNodeType::__Unknown(value),
		}
	}
}

impl StaticType for GcPropertyNodeType {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_property_node_type_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcPropertyNodeType {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcPropertyNodeType {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcPropertyNodeType {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Number representation formats.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcRepresentation {
	Undefined,
	Linear,
	Logarithmic,
	Boolean,
	PureNumber,
	HexNumber,
	Ipv4Address,
	MacAddress,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcRepresentation {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcRepresentation::{}",
			match *self {
				GcRepresentation::Undefined => "Undefined",
				GcRepresentation::Linear => "Linear",
				GcRepresentation::Logarithmic => "Logarithmic",
				GcRepresentation::Boolean => "Boolean",
				GcRepresentation::PureNumber => "PureNumber",
				GcRepresentation::HexNumber => "HexNumber",
				GcRepresentation::Ipv4Address => "Ipv4Address",
				GcRepresentation::MacAddress => "MacAddress",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcRepresentation {
	type GlibType = aravis_sys::ArvGcRepresentation;

	fn to_glib(&self) -> aravis_sys::ArvGcRepresentation {
		match *self {
			GcRepresentation::Undefined => aravis_sys::ARV_GC_REPRESENTATION_UNDEFINED,
			GcRepresentation::Linear => aravis_sys::ARV_GC_REPRESENTATION_LINEAR,
			GcRepresentation::Logarithmic => aravis_sys::ARV_GC_REPRESENTATION_LOGARITHMIC,
			GcRepresentation::Boolean => aravis_sys::ARV_GC_REPRESENTATION_BOOLEAN,
			GcRepresentation::PureNumber => aravis_sys::ARV_GC_REPRESENTATION_PURE_NUMBER,
			GcRepresentation::HexNumber => aravis_sys::ARV_GC_REPRESENTATION_HEX_NUMBER,
			GcRepresentation::Ipv4Address => aravis_sys::ARV_GC_REPRESENTATION_IPV4_ADDRESS,
			GcRepresentation::MacAddress => aravis_sys::ARV_GC_REPRESENTATION_MAC_ADDRESS,
			GcRepresentation::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcRepresentation> for GcRepresentation {
	fn from_glib(value: aravis_sys::ArvGcRepresentation) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcRepresentation::Undefined,
			0 => GcRepresentation::Linear,
			1 => GcRepresentation::Logarithmic,
			2 => GcRepresentation::Boolean,
			3 => GcRepresentation::PureNumber,
			4 => GcRepresentation::HexNumber,
			5 => GcRepresentation::Ipv4Address,
			6 => GcRepresentation::MacAddress,
			value => GcRepresentation::__Unknown(value),
		}
	}
}

impl StaticType for GcRepresentation {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_representation_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcRepresentation {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcRepresentation {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcRepresentation {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Specifies signedness of integer registers. Per standard Genicam internally uses signed 64-bit
/// signed integers for representing all integer registers. Therefore unsigned 64-bit integers are
/// not available.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcSignedness {
	Undefined,
	Signed,
	Unsigned,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcSignedness {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcSignedness::{}",
			match *self {
				GcSignedness::Undefined => "Undefined",
				GcSignedness::Signed => "Signed",
				GcSignedness::Unsigned => "Unsigned",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcSignedness {
	type GlibType = aravis_sys::ArvGcSignedness;

	fn to_glib(&self) -> aravis_sys::ArvGcSignedness {
		match *self {
			GcSignedness::Undefined => aravis_sys::ARV_GC_SIGNEDNESS_UNDEFINED,
			GcSignedness::Signed => aravis_sys::ARV_GC_SIGNEDNESS_SIGNED,
			GcSignedness::Unsigned => aravis_sys::ARV_GC_SIGNEDNESS_UNSIGNED,
			GcSignedness::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcSignedness> for GcSignedness {
	fn from_glib(value: aravis_sys::ArvGcSignedness) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcSignedness::Undefined,
			0 => GcSignedness::Signed,
			1 => GcSignedness::Unsigned,
			value => GcSignedness::__Unknown(value),
		}
	}
}

impl StaticType for GcSignedness {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_signedness_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcSignedness {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcSignedness {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcSignedness {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Specifies feature node recommended visibility in user interfaces.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcVisibility {
	Undefined,
	Invisible,
	Guru,
	Expert,
	Beginner,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcVisibility {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcVisibility::{}",
			match *self {
				GcVisibility::Undefined => "Undefined",
				GcVisibility::Invisible => "Invisible",
				GcVisibility::Guru => "Guru",
				GcVisibility::Expert => "Expert",
				GcVisibility::Beginner => "Beginner",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcVisibility {
	type GlibType = aravis_sys::ArvGcVisibility;

	fn to_glib(&self) -> aravis_sys::ArvGcVisibility {
		match *self {
			GcVisibility::Undefined => aravis_sys::ARV_GC_VISIBILITY_UNDEFINED,
			GcVisibility::Invisible => aravis_sys::ARV_GC_VISIBILITY_INVISIBLE,
			GcVisibility::Guru => aravis_sys::ARV_GC_VISIBILITY_GURU,
			GcVisibility::Expert => aravis_sys::ARV_GC_VISIBILITY_EXPERT,
			GcVisibility::Beginner => aravis_sys::ARV_GC_VISIBILITY_BEGINNER,
			GcVisibility::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcVisibility> for GcVisibility {
	fn from_glib(value: aravis_sys::ArvGcVisibility) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcVisibility::Undefined,
			0 => GcVisibility::Invisible,
			1 => GcVisibility::Guru,
			2 => GcVisibility::Expert,
			3 => GcVisibility::Beginner,
			value => GcVisibility::__Unknown(value),
		}
	}
}

impl StaticType for GcVisibility {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_visibility_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcVisibility {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcVisibility {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcVisibility {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GvPacketSizeAdjustment {
	Never,
	OnFailureOnce,
	OnFailure,
	Once,
	Always,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GvPacketSizeAdjustment {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GvPacketSizeAdjustment::{}",
			match *self {
				GvPacketSizeAdjustment::Never => "Never",
				GvPacketSizeAdjustment::OnFailureOnce => "OnFailureOnce",
				GvPacketSizeAdjustment::OnFailure => "OnFailure",
				GvPacketSizeAdjustment::Once => "Once",
				GvPacketSizeAdjustment::Always => "Always",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GvPacketSizeAdjustment {
	type GlibType = aravis_sys::ArvGvPacketSizeAdjustment;

	fn to_glib(&self) -> aravis_sys::ArvGvPacketSizeAdjustment {
		match *self {
			GvPacketSizeAdjustment::Never => aravis_sys::ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER,
			GvPacketSizeAdjustment::OnFailureOnce => {
				aravis_sys::ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE
			}
			GvPacketSizeAdjustment::OnFailure => {
				aravis_sys::ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE
			}
			GvPacketSizeAdjustment::Once => aravis_sys::ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE,
			GvPacketSizeAdjustment::Always => aravis_sys::ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS,
			GvPacketSizeAdjustment::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGvPacketSizeAdjustment> for GvPacketSizeAdjustment {
	fn from_glib(value: aravis_sys::ArvGvPacketSizeAdjustment) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GvPacketSizeAdjustment::Never,
			1 => GvPacketSizeAdjustment::OnFailureOnce,
			2 => GvPacketSizeAdjustment::OnFailure,
			3 => GvPacketSizeAdjustment::Once,
			4 => GvPacketSizeAdjustment::Always,
			value => GvPacketSizeAdjustment::__Unknown(value),
		}
	}
}

impl StaticType for GvPacketSizeAdjustment {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gv_packet_size_adjustment_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GvPacketSizeAdjustment {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GvPacketSizeAdjustment {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GvPacketSizeAdjustment {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GvStreamOption {
	None,
	PacketSocketDisabled,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GvStreamOption {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GvStreamOption::{}",
			match *self {
				GvStreamOption::None => "None",
				GvStreamOption::PacketSocketDisabled => "PacketSocketDisabled",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GvStreamOption {
	type GlibType = aravis_sys::ArvGvStreamOption;

	fn to_glib(&self) -> aravis_sys::ArvGvStreamOption {
		match *self {
			GvStreamOption::None => aravis_sys::ARV_GV_STREAM_OPTION_NONE,
			GvStreamOption::PacketSocketDisabled => {
				aravis_sys::ARV_GV_STREAM_OPTION_PACKET_SOCKET_DISABLED
			}
			GvStreamOption::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGvStreamOption> for GvStreamOption {
	fn from_glib(value: aravis_sys::ArvGvStreamOption) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GvStreamOption::None,
			1 => GvStreamOption::PacketSocketDisabled,
			value => GvStreamOption::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamOption {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gv_stream_option_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GvStreamOption {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GvStreamOption {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GvStreamOption {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GvStreamPacketResend {
	Never,
	Always,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GvStreamPacketResend {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GvStreamPacketResend::{}",
			match *self {
				GvStreamPacketResend::Never => "Never",
				GvStreamPacketResend::Always => "Always",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GvStreamPacketResend {
	type GlibType = aravis_sys::ArvGvStreamPacketResend;

	fn to_glib(&self) -> aravis_sys::ArvGvStreamPacketResend {
		match *self {
			GvStreamPacketResend::Never => aravis_sys::ARV_GV_STREAM_PACKET_RESEND_NEVER,
			GvStreamPacketResend::Always => aravis_sys::ARV_GV_STREAM_PACKET_RESEND_ALWAYS,
			GvStreamPacketResend::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGvStreamPacketResend> for GvStreamPacketResend {
	fn from_glib(value: aravis_sys::ArvGvStreamPacketResend) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GvStreamPacketResend::Never,
			1 => GvStreamPacketResend::Always,
			value => GvStreamPacketResend::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamPacketResend {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gv_stream_packet_resend_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GvStreamPacketResend {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GvStreamPacketResend {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GvStreamPacketResend {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GvStreamSocketBuffer {
	Fixed,
	Auto,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GvStreamSocketBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GvStreamSocketBuffer::{}",
			match *self {
				GvStreamSocketBuffer::Fixed => "Fixed",
				GvStreamSocketBuffer::Auto => "Auto",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GvStreamSocketBuffer {
	type GlibType = aravis_sys::ArvGvStreamSocketBuffer;

	fn to_glib(&self) -> aravis_sys::ArvGvStreamSocketBuffer {
		match *self {
			GvStreamSocketBuffer::Fixed => aravis_sys::ARV_GV_STREAM_SOCKET_BUFFER_FIXED,
			GvStreamSocketBuffer::Auto => aravis_sys::ARV_GV_STREAM_SOCKET_BUFFER_AUTO,
			GvStreamSocketBuffer::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGvStreamSocketBuffer> for GvStreamSocketBuffer {
	fn from_glib(value: aravis_sys::ArvGvStreamSocketBuffer) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GvStreamSocketBuffer::Fixed,
			1 => GvStreamSocketBuffer::Auto,
			value => GvStreamSocketBuffer::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamSocketBuffer {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gv_stream_socket_buffer_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GvStreamSocketBuffer {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GvStreamSocketBuffer {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GvStreamSocketBuffer {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RegisterCachePolicy {
	Disable,
	Enable,
	Debug,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for RegisterCachePolicy {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"RegisterCachePolicy::{}",
			match *self {
				RegisterCachePolicy::Disable => "Disable",
				RegisterCachePolicy::Enable => "Enable",
				RegisterCachePolicy::Debug => "Debug",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for RegisterCachePolicy {
	type GlibType = aravis_sys::ArvRegisterCachePolicy;

	fn to_glib(&self) -> aravis_sys::ArvRegisterCachePolicy {
		match *self {
			RegisterCachePolicy::Disable => aravis_sys::ARV_REGISTER_CACHE_POLICY_DISABLE,
			RegisterCachePolicy::Enable => aravis_sys::ARV_REGISTER_CACHE_POLICY_ENABLE,
			RegisterCachePolicy::Debug => aravis_sys::ARV_REGISTER_CACHE_POLICY_DEBUG,
			RegisterCachePolicy::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvRegisterCachePolicy> for RegisterCachePolicy {
	fn from_glib(value: aravis_sys::ArvRegisterCachePolicy) -> Self {
		skip_assert_initialized!();
		match value {
			0 => RegisterCachePolicy::Disable,
			1 => RegisterCachePolicy::Enable,
			2 => RegisterCachePolicy::Debug,
			value => RegisterCachePolicy::__Unknown(value),
		}
	}
}

impl StaticType for RegisterCachePolicy {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_register_cache_policy_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for RegisterCachePolicy {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for RegisterCachePolicy {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for RegisterCachePolicy {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

/// Describes when the stream callback is called.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum StreamCallbackType {
	Init,
	Exit,
	StartBuffer,
	BufferDone,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for StreamCallbackType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"StreamCallbackType::{}",
			match *self {
				StreamCallbackType::Init => "Init",
				StreamCallbackType::Exit => "Exit",
				StreamCallbackType::StartBuffer => "StartBuffer",
				StreamCallbackType::BufferDone => "BufferDone",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for StreamCallbackType {
	type GlibType = aravis_sys::ArvStreamCallbackType;

	fn to_glib(&self) -> aravis_sys::ArvStreamCallbackType {
		match *self {
			StreamCallbackType::Init => aravis_sys::ARV_STREAM_CALLBACK_TYPE_INIT,
			StreamCallbackType::Exit => aravis_sys::ARV_STREAM_CALLBACK_TYPE_EXIT,
			StreamCallbackType::StartBuffer => aravis_sys::ARV_STREAM_CALLBACK_TYPE_START_BUFFER,
			StreamCallbackType::BufferDone => aravis_sys::ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE,
			StreamCallbackType::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvStreamCallbackType> for StreamCallbackType {
	fn from_glib(value: aravis_sys::ArvStreamCallbackType) -> Self {
		skip_assert_initialized!();
		match value {
			0 => StreamCallbackType::Init,
			1 => StreamCallbackType::Exit,
			2 => StreamCallbackType::StartBuffer,
			3 => StreamCallbackType::BufferDone,
			value => StreamCallbackType::__Unknown(value),
		}
	}
}

impl StaticType for StreamCallbackType {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_stream_callback_type_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for StreamCallbackType {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for StreamCallbackType {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for StreamCallbackType {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum XmlSchemaError {
	Structure,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for XmlSchemaError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"XmlSchemaError::{}",
			match *self {
				XmlSchemaError::Structure => "Structure",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for XmlSchemaError {
	type GlibType = aravis_sys::ArvXmlSchemaError;

	fn to_glib(&self) -> aravis_sys::ArvXmlSchemaError {
		match *self {
			XmlSchemaError::Structure => aravis_sys::ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE,
			XmlSchemaError::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvXmlSchemaError> for XmlSchemaError {
	fn from_glib(value: aravis_sys::ArvXmlSchemaError) -> Self {
		skip_assert_initialized!();
		match value {
			0 => XmlSchemaError::Structure,
			value => XmlSchemaError::__Unknown(value),
		}
	}
}

impl ErrorDomain for XmlSchemaError {
	fn domain() -> Quark {
		skip_assert_initialized!();

		unsafe { from_glib(aravis_sys::arv_xml_schema_error_quark()) }
	}

	fn code(self) -> i32 {
		self.to_glib()
	}

	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match code {
			0 => Some(XmlSchemaError::Structure),
			value => Some(XmlSchemaError::__Unknown(value)),
		}
	}
}

impl StaticType for XmlSchemaError {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_xml_schema_error_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for XmlSchemaError {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for XmlSchemaError {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for XmlSchemaError {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}
