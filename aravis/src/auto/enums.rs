// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use aravis_sys;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AcquisitionMode {
	Continuous,
	SingleFrame,
	MultiFrame,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for AcquisitionMode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"AcquisitionMode::{}",
			match *self {
				AcquisitionMode::Continuous => "Continuous",
				AcquisitionMode::SingleFrame => "SingleFrame",
				AcquisitionMode::MultiFrame => "MultiFrame",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for AcquisitionMode {
	type GlibType = aravis_sys::ArvAcquisitionMode;

	fn to_glib(&self) -> aravis_sys::ArvAcquisitionMode {
		match *self {
			AcquisitionMode::Continuous => aravis_sys::ARV_ACQUISITION_MODE_CONTINUOUS,
			AcquisitionMode::SingleFrame => aravis_sys::ARV_ACQUISITION_MODE_SINGLE_FRAME,
			AcquisitionMode::MultiFrame => aravis_sys::ARV_ACQUISITION_MODE_MULTI_FRAME,
			AcquisitionMode::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvAcquisitionMode> for AcquisitionMode {
	fn from_glib(value: aravis_sys::ArvAcquisitionMode) -> Self {
		skip_assert_initialized!();
		match value {
			0 => AcquisitionMode::Continuous,
			1 => AcquisitionMode::SingleFrame,
			2 => AcquisitionMode::MultiFrame,
			value => AcquisitionMode::__Unknown(value),
		}
	}
}

impl StaticType for AcquisitionMode {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_acquisition_mode_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for AcquisitionMode {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for AcquisitionMode {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for AcquisitionMode {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Auto {
	Off,
	Once,
	Continuous,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for Auto {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"Auto::{}",
			match *self {
				Auto::Off => "Off",
				Auto::Once => "Once",
				Auto::Continuous => "Continuous",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for Auto {
	type GlibType = aravis_sys::ArvAuto;

	fn to_glib(&self) -> aravis_sys::ArvAuto {
		match *self {
			Auto::Off => aravis_sys::ARV_AUTO_OFF,
			Auto::Once => aravis_sys::ARV_AUTO_ONCE,
			Auto::Continuous => aravis_sys::ARV_AUTO_CONTINUOUS,
			Auto::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvAuto> for Auto {
	fn from_glib(value: aravis_sys::ArvAuto) -> Self {
		skip_assert_initialized!();
		match value {
			0 => Auto::Off,
			1 => Auto::Once,
			2 => Auto::Continuous,
			value => Auto::__Unknown(value),
		}
	}
}

impl StaticType for Auto {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_auto_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for Auto {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for Auto {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for Auto {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BufferPayloadType {
	Unknown,
	Image,
	Rawdata,
	File,
	ChunkData,
	ExtendedChunkData,
	Jpeg,
	Jpeg2000,
	H264,
	MultizoneImage,
	ImageExtendedChunk,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for BufferPayloadType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"BufferPayloadType::{}",
			match *self {
				BufferPayloadType::Unknown => "Unknown",
				BufferPayloadType::Image => "Image",
				BufferPayloadType::Rawdata => "Rawdata",
				BufferPayloadType::File => "File",
				BufferPayloadType::ChunkData => "ChunkData",
				BufferPayloadType::ExtendedChunkData => "ExtendedChunkData",
				BufferPayloadType::Jpeg => "Jpeg",
				BufferPayloadType::Jpeg2000 => "Jpeg2000",
				BufferPayloadType::H264 => "H264",
				BufferPayloadType::MultizoneImage => "MultizoneImage",
				BufferPayloadType::ImageExtendedChunk => "ImageExtendedChunk",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for BufferPayloadType {
	type GlibType = aravis_sys::ArvBufferPayloadType;

	fn to_glib(&self) -> aravis_sys::ArvBufferPayloadType {
		match *self {
			BufferPayloadType::Unknown => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN,
			BufferPayloadType::Image => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_IMAGE,
			BufferPayloadType::Rawdata => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_RAWDATA,
			BufferPayloadType::File => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_FILE,
			BufferPayloadType::ChunkData => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA,
			BufferPayloadType::ExtendedChunkData => {
				aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA
			}
			BufferPayloadType::Jpeg => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_JPEG,
			BufferPayloadType::Jpeg2000 => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_JPEG2000,
			BufferPayloadType::H264 => aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_H264,
			BufferPayloadType::MultizoneImage => {
				aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE
			}
			BufferPayloadType::ImageExtendedChunk => {
				aravis_sys::ARV_BUFFER_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK
			}
			BufferPayloadType::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvBufferPayloadType> for BufferPayloadType {
	fn from_glib(value: aravis_sys::ArvBufferPayloadType) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => BufferPayloadType::Unknown,
			1 => BufferPayloadType::Image,
			2 => BufferPayloadType::Rawdata,
			3 => BufferPayloadType::File,
			4 => BufferPayloadType::ChunkData,
			5 => BufferPayloadType::ExtendedChunkData,
			6 => BufferPayloadType::Jpeg,
			7 => BufferPayloadType::Jpeg2000,
			8 => BufferPayloadType::H264,
			9 => BufferPayloadType::MultizoneImage,
			16385 => BufferPayloadType::ImageExtendedChunk,
			value => BufferPayloadType::__Unknown(value),
		}
	}
}

impl StaticType for BufferPayloadType {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_buffer_payload_type_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for BufferPayloadType {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for BufferPayloadType {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for BufferPayloadType {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BufferStatus {
	Unknown,
	Success,
	Cleared,
	Timeout,
	MissingPackets,
	WrongPacketId,
	SizeMismatch,
	Filling,
	Aborted,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for BufferStatus {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"BufferStatus::{}",
			match *self {
				BufferStatus::Unknown => "Unknown",
				BufferStatus::Success => "Success",
				BufferStatus::Cleared => "Cleared",
				BufferStatus::Timeout => "Timeout",
				BufferStatus::MissingPackets => "MissingPackets",
				BufferStatus::WrongPacketId => "WrongPacketId",
				BufferStatus::SizeMismatch => "SizeMismatch",
				BufferStatus::Filling => "Filling",
				BufferStatus::Aborted => "Aborted",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for BufferStatus {
	type GlibType = aravis_sys::ArvBufferStatus;

	fn to_glib(&self) -> aravis_sys::ArvBufferStatus {
		match *self {
			BufferStatus::Unknown => aravis_sys::ARV_BUFFER_STATUS_UNKNOWN,
			BufferStatus::Success => aravis_sys::ARV_BUFFER_STATUS_SUCCESS,
			BufferStatus::Cleared => aravis_sys::ARV_BUFFER_STATUS_CLEARED,
			BufferStatus::Timeout => aravis_sys::ARV_BUFFER_STATUS_TIMEOUT,
			BufferStatus::MissingPackets => aravis_sys::ARV_BUFFER_STATUS_MISSING_PACKETS,
			BufferStatus::WrongPacketId => aravis_sys::ARV_BUFFER_STATUS_WRONG_PACKET_ID,
			BufferStatus::SizeMismatch => aravis_sys::ARV_BUFFER_STATUS_SIZE_MISMATCH,
			BufferStatus::Filling => aravis_sys::ARV_BUFFER_STATUS_FILLING,
			BufferStatus::Aborted => aravis_sys::ARV_BUFFER_STATUS_ABORTED,
			BufferStatus::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvBufferStatus> for BufferStatus {
	fn from_glib(value: aravis_sys::ArvBufferStatus) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => BufferStatus::Unknown,
			0 => BufferStatus::Success,
			1 => BufferStatus::Cleared,
			2 => BufferStatus::Timeout,
			3 => BufferStatus::MissingPackets,
			4 => BufferStatus::WrongPacketId,
			5 => BufferStatus::SizeMismatch,
			6 => BufferStatus::Filling,
			7 => BufferStatus::Aborted,
			value => BufferStatus::__Unknown(value),
		}
	}
}

impl StaticType for BufferStatus {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_buffer_status_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for BufferStatus {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for BufferStatus {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for BufferStatus {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DebugLevel {
	None,
	Warning,
	Debug,
	Log,
	Count,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for DebugLevel {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"DebugLevel::{}",
			match *self {
				DebugLevel::None => "None",
				DebugLevel::Warning => "Warning",
				DebugLevel::Debug => "Debug",
				DebugLevel::Log => "Log",
				DebugLevel::Count => "Count",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for DebugLevel {
	type GlibType = aravis_sys::ArvDebugLevel;

	fn to_glib(&self) -> aravis_sys::ArvDebugLevel {
		match *self {
			DebugLevel::None => aravis_sys::ARV_DEBUG_LEVEL_NONE,
			DebugLevel::Warning => aravis_sys::ARV_DEBUG_LEVEL_WARNING,
			DebugLevel::Debug => aravis_sys::ARV_DEBUG_LEVEL_DEBUG,
			DebugLevel::Log => aravis_sys::ARV_DEBUG_LEVEL_LOG,
			DebugLevel::Count => aravis_sys::ARV_DEBUG_LEVEL_COUNT,
			DebugLevel::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvDebugLevel> for DebugLevel {
	fn from_glib(value: aravis_sys::ArvDebugLevel) -> Self {
		skip_assert_initialized!();
		match value {
			0 => DebugLevel::None,
			1 => DebugLevel::Warning,
			2 => DebugLevel::Debug,
			3 => DebugLevel::Log,
			4 => DebugLevel::Count,
			value => DebugLevel::__Unknown(value),
		}
	}
}

impl StaticType for DebugLevel {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_debug_level_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for DebugLevel {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for DebugLevel {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for DebugLevel {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DomNodeType {
	ElementNode,
	AttributeNode,
	TextNode,
	CdataSectionNode,
	EntityReferenceNode,
	EntityNode,
	ProcessingInstructionNode,
	CommentNode,
	DocumentNode,
	DocumentTypeNode,
	DocumentFragmentNode,
	NotationNode,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for DomNodeType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"DomNodeType::{}",
			match *self {
				DomNodeType::ElementNode => "ElementNode",
				DomNodeType::AttributeNode => "AttributeNode",
				DomNodeType::TextNode => "TextNode",
				DomNodeType::CdataSectionNode => "CdataSectionNode",
				DomNodeType::EntityReferenceNode => "EntityReferenceNode",
				DomNodeType::EntityNode => "EntityNode",
				DomNodeType::ProcessingInstructionNode => "ProcessingInstructionNode",
				DomNodeType::CommentNode => "CommentNode",
				DomNodeType::DocumentNode => "DocumentNode",
				DomNodeType::DocumentTypeNode => "DocumentTypeNode",
				DomNodeType::DocumentFragmentNode => "DocumentFragmentNode",
				DomNodeType::NotationNode => "NotationNode",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for DomNodeType {
	type GlibType = aravis_sys::ArvDomNodeType;

	fn to_glib(&self) -> aravis_sys::ArvDomNodeType {
		match *self {
			DomNodeType::ElementNode => aravis_sys::ARV_DOM_NODE_TYPE_ELEMENT_NODE,
			DomNodeType::AttributeNode => aravis_sys::ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE,
			DomNodeType::TextNode => aravis_sys::ARV_DOM_NODE_TYPE_TEXT_NODE,
			DomNodeType::CdataSectionNode => aravis_sys::ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE,
			DomNodeType::EntityReferenceNode => aravis_sys::ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE,
			DomNodeType::EntityNode => aravis_sys::ARV_DOM_NODE_TYPE_ENTITY_NODE,
			DomNodeType::ProcessingInstructionNode => {
				aravis_sys::ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE
			}
			DomNodeType::CommentNode => aravis_sys::ARV_DOM_NODE_TYPE_COMMENT_NODE,
			DomNodeType::DocumentNode => aravis_sys::ARV_DOM_NODE_TYPE_DOCUMENT_NODE,
			DomNodeType::DocumentTypeNode => aravis_sys::ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE,
			DomNodeType::DocumentFragmentNode => {
				aravis_sys::ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE
			}
			DomNodeType::NotationNode => aravis_sys::ARV_DOM_NODE_TYPE_NOTATION_NODE,
			DomNodeType::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvDomNodeType> for DomNodeType {
	fn from_glib(value: aravis_sys::ArvDomNodeType) -> Self {
		skip_assert_initialized!();
		match value {
			1 => DomNodeType::ElementNode,
			2 => DomNodeType::AttributeNode,
			3 => DomNodeType::TextNode,
			4 => DomNodeType::CdataSectionNode,
			5 => DomNodeType::EntityReferenceNode,
			6 => DomNodeType::EntityNode,
			7 => DomNodeType::ProcessingInstructionNode,
			8 => DomNodeType::CommentNode,
			9 => DomNodeType::DocumentNode,
			10 => DomNodeType::DocumentTypeNode,
			11 => DomNodeType::DocumentFragmentNode,
			12 => DomNodeType::NotationNode,
			value => DomNodeType::__Unknown(value),
		}
	}
}

impl StaticType for DomNodeType {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_dom_node_type_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for DomNodeType {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for DomNodeType {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for DomNodeType {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcAccessMode {
	Undefined,
	Ro,
	Wo,
	Rw,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcAccessMode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcAccessMode::{}",
			match *self {
				GcAccessMode::Undefined => "Undefined",
				GcAccessMode::Ro => "Ro",
				GcAccessMode::Wo => "Wo",
				GcAccessMode::Rw => "Rw",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcAccessMode {
	type GlibType = aravis_sys::ArvGcAccessMode;

	fn to_glib(&self) -> aravis_sys::ArvGcAccessMode {
		match *self {
			GcAccessMode::Undefined => aravis_sys::ARV_GC_ACCESS_MODE_UNDEFINED,
			GcAccessMode::Ro => aravis_sys::ARV_GC_ACCESS_MODE_RO,
			GcAccessMode::Wo => aravis_sys::ARV_GC_ACCESS_MODE_WO,
			GcAccessMode::Rw => aravis_sys::ARV_GC_ACCESS_MODE_RW,
			GcAccessMode::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcAccessMode> for GcAccessMode {
	fn from_glib(value: aravis_sys::ArvGcAccessMode) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcAccessMode::Undefined,
			0 => GcAccessMode::Ro,
			1 => GcAccessMode::Wo,
			2 => GcAccessMode::Rw,
			value => GcAccessMode::__Unknown(value),
		}
	}
}

impl StaticType for GcAccessMode {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_access_mode_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcAccessMode {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcAccessMode {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcAccessMode {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcCachable {
	Undefined,
	NoCache,
	WriteThrough,
	WriteAround,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcCachable {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcCachable::{}",
			match *self {
				GcCachable::Undefined => "Undefined",
				GcCachable::NoCache => "NoCache",
				GcCachable::WriteThrough => "WriteThrough",
				GcCachable::WriteAround => "WriteAround",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcCachable {
	type GlibType = aravis_sys::ArvGcCachable;

	fn to_glib(&self) -> aravis_sys::ArvGcCachable {
		match *self {
			GcCachable::Undefined => aravis_sys::ARV_GC_CACHABLE_UNDEFINED,
			GcCachable::NoCache => aravis_sys::ARV_GC_CACHABLE_NO_CACHE,
			GcCachable::WriteThrough => aravis_sys::ARV_GC_CACHABLE_WRITE_THROUGH,
			GcCachable::WriteAround => aravis_sys::ARV_GC_CACHABLE_WRITE_AROUND,
			GcCachable::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcCachable> for GcCachable {
	fn from_glib(value: aravis_sys::ArvGcCachable) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcCachable::Undefined,
			0 => GcCachable::NoCache,
			1 => GcCachable::WriteThrough,
			2 => GcCachable::WriteAround,
			value => GcCachable::__Unknown(value),
		}
	}
}

impl StaticType for GcCachable {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_cachable_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcCachable {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcCachable {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcCachable {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcError {
	PropertyNotDefined,
	PvalueNotDefined,
	InvalidPvalue,
	EmptyEnumeration,
	OutOfRange,
	NoDeviceSet,
	NoEventImplementation,
	NodeNotFound,
	EnumEntryNotFound,
	InvalidLength,
	ReadOnly,
	SetFromStringUndefined,
	GetAsStringUndefined,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcError::{}",
			match *self {
				GcError::PropertyNotDefined => "PropertyNotDefined",
				GcError::PvalueNotDefined => "PvalueNotDefined",
				GcError::InvalidPvalue => "InvalidPvalue",
				GcError::EmptyEnumeration => "EmptyEnumeration",
				GcError::OutOfRange => "OutOfRange",
				GcError::NoDeviceSet => "NoDeviceSet",
				GcError::NoEventImplementation => "NoEventImplementation",
				GcError::NodeNotFound => "NodeNotFound",
				GcError::EnumEntryNotFound => "EnumEntryNotFound",
				GcError::InvalidLength => "InvalidLength",
				GcError::ReadOnly => "ReadOnly",
				GcError::SetFromStringUndefined => "SetFromStringUndefined",
				GcError::GetAsStringUndefined => "GetAsStringUndefined",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcError {
	type GlibType = aravis_sys::ArvGcError;

	fn to_glib(&self) -> aravis_sys::ArvGcError {
		match *self {
			GcError::PropertyNotDefined => aravis_sys::ARV_GC_ERROR_PROPERTY_NOT_DEFINED,
			GcError::PvalueNotDefined => aravis_sys::ARV_GC_ERROR_PVALUE_NOT_DEFINED,
			GcError::InvalidPvalue => aravis_sys::ARV_GC_ERROR_INVALID_PVALUE,
			GcError::EmptyEnumeration => aravis_sys::ARV_GC_ERROR_EMPTY_ENUMERATION,
			GcError::OutOfRange => aravis_sys::ARV_GC_ERROR_OUT_OF_RANGE,
			GcError::NoDeviceSet => aravis_sys::ARV_GC_ERROR_NO_DEVICE_SET,
			GcError::NoEventImplementation => aravis_sys::ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION,
			GcError::NodeNotFound => aravis_sys::ARV_GC_ERROR_NODE_NOT_FOUND,
			GcError::EnumEntryNotFound => aravis_sys::ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND,
			GcError::InvalidLength => aravis_sys::ARV_GC_ERROR_INVALID_LENGTH,
			GcError::ReadOnly => aravis_sys::ARV_GC_ERROR_READ_ONLY,
			GcError::SetFromStringUndefined => aravis_sys::ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED,
			GcError::GetAsStringUndefined => aravis_sys::ARV_GC_ERROR_GET_AS_STRING_UNDEFINED,
			GcError::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcError> for GcError {
	fn from_glib(value: aravis_sys::ArvGcError) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GcError::PropertyNotDefined,
			1 => GcError::PvalueNotDefined,
			2 => GcError::InvalidPvalue,
			3 => GcError::EmptyEnumeration,
			4 => GcError::OutOfRange,
			5 => GcError::NoDeviceSet,
			6 => GcError::NoEventImplementation,
			7 => GcError::NodeNotFound,
			8 => GcError::EnumEntryNotFound,
			9 => GcError::InvalidLength,
			10 => GcError::ReadOnly,
			11 => GcError::SetFromStringUndefined,
			12 => GcError::GetAsStringUndefined,
			value => GcError::__Unknown(value),
		}
	}
}

impl ErrorDomain for GcError {
	fn domain() -> Quark {
		skip_assert_initialized!();
		unsafe { from_glib(aravis_sys::arv_gc_error_quark()) }
	}

	fn code(self) -> i32 {
		self.to_glib()
	}

	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match code {
			0 => Some(GcError::PropertyNotDefined),
			1 => Some(GcError::PvalueNotDefined),
			2 => Some(GcError::InvalidPvalue),
			3 => Some(GcError::EmptyEnumeration),
			4 => Some(GcError::OutOfRange),
			5 => Some(GcError::NoDeviceSet),
			6 => Some(GcError::NoEventImplementation),
			7 => Some(GcError::NodeNotFound),
			8 => Some(GcError::EnumEntryNotFound),
			9 => Some(GcError::InvalidLength),
			10 => Some(GcError::ReadOnly),
			11 => Some(GcError::SetFromStringUndefined),
			12 => Some(GcError::GetAsStringUndefined),
			value => Some(GcError::__Unknown(value)),
		}
	}
}

impl StaticType for GcError {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_error_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcError {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcError {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcError {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcIsLinear {
	Undefined,
	No,
	Yes,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcIsLinear {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcIsLinear::{}",
			match *self {
				GcIsLinear::Undefined => "Undefined",
				GcIsLinear::No => "No",
				GcIsLinear::Yes => "Yes",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcIsLinear {
	type GlibType = aravis_sys::ArvGcIsLinear;

	fn to_glib(&self) -> aravis_sys::ArvGcIsLinear {
		match *self {
			GcIsLinear::Undefined => aravis_sys::ARV_GC_IS_LINEAR_UNDEFINED,
			GcIsLinear::No => aravis_sys::ARV_GC_IS_LINEAR_NO,
			GcIsLinear::Yes => aravis_sys::ARV_GC_IS_LINEAR_YES,
			GcIsLinear::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcIsLinear> for GcIsLinear {
	fn from_glib(value: aravis_sys::ArvGcIsLinear) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcIsLinear::Undefined,
			0 => GcIsLinear::No,
			1 => GcIsLinear::Yes,
			value => GcIsLinear::__Unknown(value),
		}
	}
}

impl StaticType for GcIsLinear {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_is_linear_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcIsLinear {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcIsLinear {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcIsLinear {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcNameSpace {
	Undefined,
	Standard,
	Custom,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcNameSpace {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcNameSpace::{}",
			match *self {
				GcNameSpace::Undefined => "Undefined",
				GcNameSpace::Standard => "Standard",
				GcNameSpace::Custom => "Custom",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcNameSpace {
	type GlibType = aravis_sys::ArvGcNameSpace;

	fn to_glib(&self) -> aravis_sys::ArvGcNameSpace {
		match *self {
			GcNameSpace::Undefined => aravis_sys::ARV_GC_NAME_SPACE_UNDEFINED,
			GcNameSpace::Standard => aravis_sys::ARV_GC_NAME_SPACE_STANDARD,
			GcNameSpace::Custom => aravis_sys::ARV_GC_NAME_SPACE_CUSTOM,
			GcNameSpace::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcNameSpace> for GcNameSpace {
	fn from_glib(value: aravis_sys::ArvGcNameSpace) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcNameSpace::Undefined,
			0 => GcNameSpace::Standard,
			1 => GcNameSpace::Custom,
			value => GcNameSpace::__Unknown(value),
		}
	}
}

impl StaticType for GcNameSpace {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_name_space_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcNameSpace {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcNameSpace {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcNameSpace {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcPropertyNodeType {
	Unknown,
	Value,
	Address,
	Description,
	Visibility,
	Tooltip,
	DisplayName,
	Minimum,
	Maximum,
	Slope,
	Increment,
	IsLinear,
	Unit,
	OnValue,
	OffValue,
	Length,
	Formula,
	FormulaTo,
	FormulaFrom,
	Expression,
	Constant,
	AccessMode,
	ImposedAccessMode,
	Cachable,
	PollingTime,
	Endianness,
	Sign,
	Lsb,
	Msb,
	Bit,
	CommandValue,
	ChunkId,
	EventId,
	ValueIndexed,
	ValueDefault,
	PUnknonw,
	PFeature,
	PValue,
	PAddress,
	PIsImplemented,
	PIsLocked,
	PIsAvailable,
	PSelected,
	PMinimum,
	PMaximum,
	PIncrement,
	PIndex,
	PLength,
	PPort,
	PVariable,
	PInvalidator,
	PCommandValue,
	PValueIndexed,
	PValueDefault,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcPropertyNodeType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcPropertyNodeType::{}",
			match *self {
				GcPropertyNodeType::Unknown => "Unknown",
				GcPropertyNodeType::Value => "Value",
				GcPropertyNodeType::Address => "Address",
				GcPropertyNodeType::Description => "Description",
				GcPropertyNodeType::Visibility => "Visibility",
				GcPropertyNodeType::Tooltip => "Tooltip",
				GcPropertyNodeType::DisplayName => "DisplayName",
				GcPropertyNodeType::Minimum => "Minimum",
				GcPropertyNodeType::Maximum => "Maximum",
				GcPropertyNodeType::Slope => "Slope",
				GcPropertyNodeType::Increment => "Increment",
				GcPropertyNodeType::IsLinear => "IsLinear",
				GcPropertyNodeType::Unit => "Unit",
				GcPropertyNodeType::OnValue => "OnValue",
				GcPropertyNodeType::OffValue => "OffValue",
				GcPropertyNodeType::Length => "Length",
				GcPropertyNodeType::Formula => "Formula",
				GcPropertyNodeType::FormulaTo => "FormulaTo",
				GcPropertyNodeType::FormulaFrom => "FormulaFrom",
				GcPropertyNodeType::Expression => "Expression",
				GcPropertyNodeType::Constant => "Constant",
				GcPropertyNodeType::AccessMode => "AccessMode",
				GcPropertyNodeType::ImposedAccessMode => "ImposedAccessMode",
				GcPropertyNodeType::Cachable => "Cachable",
				GcPropertyNodeType::PollingTime => "PollingTime",
				GcPropertyNodeType::Endianness => "Endianness",
				GcPropertyNodeType::Sign => "Sign",
				GcPropertyNodeType::Lsb => "Lsb",
				GcPropertyNodeType::Msb => "Msb",
				GcPropertyNodeType::Bit => "Bit",
				GcPropertyNodeType::CommandValue => "CommandValue",
				GcPropertyNodeType::ChunkId => "ChunkId",
				GcPropertyNodeType::EventId => "EventId",
				GcPropertyNodeType::ValueIndexed => "ValueIndexed",
				GcPropertyNodeType::ValueDefault => "ValueDefault",
				GcPropertyNodeType::PUnknonw => "PUnknonw",
				GcPropertyNodeType::PFeature => "PFeature",
				GcPropertyNodeType::PValue => "PValue",
				GcPropertyNodeType::PAddress => "PAddress",
				GcPropertyNodeType::PIsImplemented => "PIsImplemented",
				GcPropertyNodeType::PIsLocked => "PIsLocked",
				GcPropertyNodeType::PIsAvailable => "PIsAvailable",
				GcPropertyNodeType::PSelected => "PSelected",
				GcPropertyNodeType::PMinimum => "PMinimum",
				GcPropertyNodeType::PMaximum => "PMaximum",
				GcPropertyNodeType::PIncrement => "PIncrement",
				GcPropertyNodeType::PIndex => "PIndex",
				GcPropertyNodeType::PLength => "PLength",
				GcPropertyNodeType::PPort => "PPort",
				GcPropertyNodeType::PVariable => "PVariable",
				GcPropertyNodeType::PInvalidator => "PInvalidator",
				GcPropertyNodeType::PCommandValue => "PCommandValue",
				GcPropertyNodeType::PValueIndexed => "PValueIndexed",
				GcPropertyNodeType::PValueDefault => "PValueDefault",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcPropertyNodeType {
	type GlibType = aravis_sys::ArvGcPropertyNodeType;

	fn to_glib(&self) -> aravis_sys::ArvGcPropertyNodeType {
		match *self {
			GcPropertyNodeType::Unknown => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN,
			GcPropertyNodeType::Value => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VALUE,
			GcPropertyNodeType::Address => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ADDRESS,
			GcPropertyNodeType::Description => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION,
			GcPropertyNodeType::Visibility => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY,
			GcPropertyNodeType::Tooltip => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP,
			GcPropertyNodeType::DisplayName => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME,
			GcPropertyNodeType::Minimum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_MINIMUM,
			GcPropertyNodeType::Maximum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM,
			GcPropertyNodeType::Slope => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_SLOPE,
			GcPropertyNodeType::Increment => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_INCREMENT,
			GcPropertyNodeType::IsLinear => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR,
			GcPropertyNodeType::Unit => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_UNIT,
			GcPropertyNodeType::OnValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE,
			GcPropertyNodeType::OffValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE,
			GcPropertyNodeType::Length => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_LENGTH,
			GcPropertyNodeType::Formula => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_FORMULA,
			GcPropertyNodeType::FormulaTo => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO,
			GcPropertyNodeType::FormulaFrom => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM,
			GcPropertyNodeType::Expression => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION,
			GcPropertyNodeType::Constant => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_CONSTANT,
			GcPropertyNodeType::AccessMode => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE,
			GcPropertyNodeType::ImposedAccessMode => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE
			}
			GcPropertyNodeType::Cachable => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_CACHABLE,
			GcPropertyNodeType::PollingTime => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME,
			GcPropertyNodeType::Endianness => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS,
			GcPropertyNodeType::Sign => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_SIGN,
			GcPropertyNodeType::Lsb => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_LSB,
			GcPropertyNodeType::Msb => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_MSB,
			GcPropertyNodeType::Bit => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_BIT,
			GcPropertyNodeType::CommandValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE,
			GcPropertyNodeType::ChunkId => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID,
			GcPropertyNodeType::EventId => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID,
			GcPropertyNodeType::ValueIndexed => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED,
			GcPropertyNodeType::ValueDefault => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT,
			GcPropertyNodeType::PUnknonw => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW,
			GcPropertyNodeType::PFeature => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE,
			GcPropertyNodeType::PValue => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE,
			GcPropertyNodeType::PAddress => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS,
			GcPropertyNodeType::PIsImplemented => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED
			}
			GcPropertyNodeType::PIsLocked => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED,
			GcPropertyNodeType::PIsAvailable => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE
			}
			GcPropertyNodeType::PSelected => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED,
			GcPropertyNodeType::PMinimum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM,
			GcPropertyNodeType::PMaximum => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM,
			GcPropertyNodeType::PIncrement => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT,
			GcPropertyNodeType::PIndex => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_INDEX,
			GcPropertyNodeType::PLength => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH,
			GcPropertyNodeType::PPort => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_PORT,
			GcPropertyNodeType::PVariable => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE,
			GcPropertyNodeType::PInvalidator => aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR,
			GcPropertyNodeType::PCommandValue => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE
			}
			GcPropertyNodeType::PValueIndexed => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED
			}
			GcPropertyNodeType::PValueDefault => {
				aravis_sys::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT
			}
			GcPropertyNodeType::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcPropertyNodeType> for GcPropertyNodeType {
	fn from_glib(value: aravis_sys::ArvGcPropertyNodeType) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GcPropertyNodeType::Unknown,
			1 => GcPropertyNodeType::Value,
			2 => GcPropertyNodeType::Address,
			3 => GcPropertyNodeType::Description,
			4 => GcPropertyNodeType::Visibility,
			5 => GcPropertyNodeType::Tooltip,
			6 => GcPropertyNodeType::DisplayName,
			7 => GcPropertyNodeType::Minimum,
			8 => GcPropertyNodeType::Maximum,
			9 => GcPropertyNodeType::Slope,
			10 => GcPropertyNodeType::Increment,
			11 => GcPropertyNodeType::IsLinear,
			12 => GcPropertyNodeType::Unit,
			13 => GcPropertyNodeType::OnValue,
			14 => GcPropertyNodeType::OffValue,
			15 => GcPropertyNodeType::Length,
			16 => GcPropertyNodeType::Formula,
			17 => GcPropertyNodeType::FormulaTo,
			18 => GcPropertyNodeType::FormulaFrom,
			19 => GcPropertyNodeType::Expression,
			20 => GcPropertyNodeType::Constant,
			21 => GcPropertyNodeType::AccessMode,
			22 => GcPropertyNodeType::ImposedAccessMode,
			23 => GcPropertyNodeType::Cachable,
			24 => GcPropertyNodeType::PollingTime,
			25 => GcPropertyNodeType::Endianness,
			26 => GcPropertyNodeType::Sign,
			27 => GcPropertyNodeType::Lsb,
			28 => GcPropertyNodeType::Msb,
			29 => GcPropertyNodeType::Bit,
			30 => GcPropertyNodeType::CommandValue,
			31 => GcPropertyNodeType::ChunkId,
			32 => GcPropertyNodeType::EventId,
			33 => GcPropertyNodeType::ValueIndexed,
			34 => GcPropertyNodeType::ValueDefault,
			1000 => GcPropertyNodeType::PUnknonw,
			1001 => GcPropertyNodeType::PFeature,
			1002 => GcPropertyNodeType::PValue,
			1003 => GcPropertyNodeType::PAddress,
			1004 => GcPropertyNodeType::PIsImplemented,
			1005 => GcPropertyNodeType::PIsLocked,
			1006 => GcPropertyNodeType::PIsAvailable,
			1007 => GcPropertyNodeType::PSelected,
			1008 => GcPropertyNodeType::PMinimum,
			1009 => GcPropertyNodeType::PMaximum,
			1010 => GcPropertyNodeType::PIncrement,
			1011 => GcPropertyNodeType::PIndex,
			1012 => GcPropertyNodeType::PLength,
			1013 => GcPropertyNodeType::PPort,
			1014 => GcPropertyNodeType::PVariable,
			1015 => GcPropertyNodeType::PInvalidator,
			1016 => GcPropertyNodeType::PCommandValue,
			1017 => GcPropertyNodeType::PValueIndexed,
			1018 => GcPropertyNodeType::PValueDefault,
			value => GcPropertyNodeType::__Unknown(value),
		}
	}
}

impl StaticType for GcPropertyNodeType {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_property_node_type_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcPropertyNodeType {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcPropertyNodeType {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcPropertyNodeType {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GcSignedness {
	Undefined,
	Signed,
	Unsigned,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GcSignedness {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GcSignedness::{}",
			match *self {
				GcSignedness::Undefined => "Undefined",
				GcSignedness::Signed => "Signed",
				GcSignedness::Unsigned => "Unsigned",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GcSignedness {
	type GlibType = aravis_sys::ArvGcSignedness;

	fn to_glib(&self) -> aravis_sys::ArvGcSignedness {
		match *self {
			GcSignedness::Undefined => aravis_sys::ARV_GC_SIGNEDNESS_UNDEFINED,
			GcSignedness::Signed => aravis_sys::ARV_GC_SIGNEDNESS_SIGNED,
			GcSignedness::Unsigned => aravis_sys::ARV_GC_SIGNEDNESS_UNSIGNED,
			GcSignedness::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGcSignedness> for GcSignedness {
	fn from_glib(value: aravis_sys::ArvGcSignedness) -> Self {
		skip_assert_initialized!();
		match value {
			-1 => GcSignedness::Undefined,
			0 => GcSignedness::Signed,
			1 => GcSignedness::Unsigned,
			value => GcSignedness::__Unknown(value),
		}
	}
}

impl StaticType for GcSignedness {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gc_signedness_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GcSignedness {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GcSignedness {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GcSignedness {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GvStreamOption {
	None,
	PacketSocketDisabled,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GvStreamOption {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GvStreamOption::{}",
			match *self {
				GvStreamOption::None => "None",
				GvStreamOption::PacketSocketDisabled => "PacketSocketDisabled",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GvStreamOption {
	type GlibType = aravis_sys::ArvGvStreamOption;

	fn to_glib(&self) -> aravis_sys::ArvGvStreamOption {
		match *self {
			GvStreamOption::None => aravis_sys::ARV_GV_STREAM_OPTION_NONE,
			GvStreamOption::PacketSocketDisabled => {
				aravis_sys::ARV_GV_STREAM_OPTION_PACKET_SOCKET_DISABLED
			}
			GvStreamOption::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGvStreamOption> for GvStreamOption {
	fn from_glib(value: aravis_sys::ArvGvStreamOption) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GvStreamOption::None,
			1 => GvStreamOption::PacketSocketDisabled,
			value => GvStreamOption::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamOption {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gv_stream_option_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GvStreamOption {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GvStreamOption {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GvStreamOption {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GvStreamPacketResend {
	Never,
	Always,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GvStreamPacketResend {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GvStreamPacketResend::{}",
			match *self {
				GvStreamPacketResend::Never => "Never",
				GvStreamPacketResend::Always => "Always",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GvStreamPacketResend {
	type GlibType = aravis_sys::ArvGvStreamPacketResend;

	fn to_glib(&self) -> aravis_sys::ArvGvStreamPacketResend {
		match *self {
			GvStreamPacketResend::Never => aravis_sys::ARV_GV_STREAM_PACKET_RESEND_NEVER,
			GvStreamPacketResend::Always => aravis_sys::ARV_GV_STREAM_PACKET_RESEND_ALWAYS,
			GvStreamPacketResend::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGvStreamPacketResend> for GvStreamPacketResend {
	fn from_glib(value: aravis_sys::ArvGvStreamPacketResend) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GvStreamPacketResend::Never,
			1 => GvStreamPacketResend::Always,
			value => GvStreamPacketResend::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamPacketResend {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gv_stream_packet_resend_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GvStreamPacketResend {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GvStreamPacketResend {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GvStreamPacketResend {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GvStreamSocketBuffer {
	Fixed,
	Auto,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for GvStreamSocketBuffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"GvStreamSocketBuffer::{}",
			match *self {
				GvStreamSocketBuffer::Fixed => "Fixed",
				GvStreamSocketBuffer::Auto => "Auto",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for GvStreamSocketBuffer {
	type GlibType = aravis_sys::ArvGvStreamSocketBuffer;

	fn to_glib(&self) -> aravis_sys::ArvGvStreamSocketBuffer {
		match *self {
			GvStreamSocketBuffer::Fixed => aravis_sys::ARV_GV_STREAM_SOCKET_BUFFER_FIXED,
			GvStreamSocketBuffer::Auto => aravis_sys::ARV_GV_STREAM_SOCKET_BUFFER_AUTO,
			GvStreamSocketBuffer::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvGvStreamSocketBuffer> for GvStreamSocketBuffer {
	fn from_glib(value: aravis_sys::ArvGvStreamSocketBuffer) -> Self {
		skip_assert_initialized!();
		match value {
			0 => GvStreamSocketBuffer::Fixed,
			1 => GvStreamSocketBuffer::Auto,
			value => GvStreamSocketBuffer::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamSocketBuffer {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_gv_stream_socket_buffer_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for GvStreamSocketBuffer {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for GvStreamSocketBuffer {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for GvStreamSocketBuffer {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RegisterCachePolicy {
	Disable,
	Enable,
	Debug,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for RegisterCachePolicy {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"RegisterCachePolicy::{}",
			match *self {
				RegisterCachePolicy::Disable => "Disable",
				RegisterCachePolicy::Enable => "Enable",
				RegisterCachePolicy::Debug => "Debug",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for RegisterCachePolicy {
	type GlibType = aravis_sys::ArvRegisterCachePolicy;

	fn to_glib(&self) -> aravis_sys::ArvRegisterCachePolicy {
		match *self {
			RegisterCachePolicy::Disable => aravis_sys::ARV_REGISTER_CACHE_POLICY_DISABLE,
			RegisterCachePolicy::Enable => aravis_sys::ARV_REGISTER_CACHE_POLICY_ENABLE,
			RegisterCachePolicy::Debug => aravis_sys::ARV_REGISTER_CACHE_POLICY_DEBUG,
			RegisterCachePolicy::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvRegisterCachePolicy> for RegisterCachePolicy {
	fn from_glib(value: aravis_sys::ArvRegisterCachePolicy) -> Self {
		skip_assert_initialized!();
		match value {
			0 => RegisterCachePolicy::Disable,
			1 => RegisterCachePolicy::Enable,
			2 => RegisterCachePolicy::Debug,
			value => RegisterCachePolicy::__Unknown(value),
		}
	}
}

impl StaticType for RegisterCachePolicy {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_register_cache_policy_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for RegisterCachePolicy {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for RegisterCachePolicy {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for RegisterCachePolicy {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum XmlSchemaError {
	Structure,
	#[doc(hidden)]
	__Unknown(i32),
}

impl fmt::Display for XmlSchemaError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"XmlSchemaError::{}",
			match *self {
				XmlSchemaError::Structure => "Structure",
				_ => "Unknown",
			}
		)
	}
}

#[doc(hidden)]
impl ToGlib for XmlSchemaError {
	type GlibType = aravis_sys::ArvXmlSchemaError;

	fn to_glib(&self) -> aravis_sys::ArvXmlSchemaError {
		match *self {
			XmlSchemaError::Structure => aravis_sys::ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE,
			XmlSchemaError::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<aravis_sys::ArvXmlSchemaError> for XmlSchemaError {
	fn from_glib(value: aravis_sys::ArvXmlSchemaError) -> Self {
		skip_assert_initialized!();
		match value {
			0 => XmlSchemaError::Structure,
			value => XmlSchemaError::__Unknown(value),
		}
	}
}

impl ErrorDomain for XmlSchemaError {
	fn domain() -> Quark {
		skip_assert_initialized!();
		unsafe { from_glib(aravis_sys::arv_xml_schema_error_quark()) }
	}

	fn code(self) -> i32 {
		self.to_glib()
	}

	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match code {
			0 => Some(XmlSchemaError::Structure),
			value => Some(XmlSchemaError::__Unknown(value)),
		}
	}
}

impl StaticType for XmlSchemaError {
	fn static_type() -> Type {
		unsafe { from_glib(aravis_sys::arv_xml_schema_error_get_type()) }
	}
}

impl<'a> FromValueOptional<'a> for XmlSchemaError {
	unsafe fn from_value_optional(value: &Value) -> Option<Self> {
		Some(FromValue::from_value(value))
	}
}

impl<'a> FromValue<'a> for XmlSchemaError {
	unsafe fn from_value(value: &Value) -> Self {
		from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
	}
}

impl SetValue for XmlSchemaError {
	unsafe fn set_value(value: &mut Value, this: &Self) {
		gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
	}
}
