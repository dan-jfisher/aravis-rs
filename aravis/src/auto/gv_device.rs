// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use aravis_sys;
use gio;
use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;
use std::ptr;
use Device;
use GvStreamOption;

glib_wrapper! {
	pub struct GvDevice(Object<aravis_sys::ArvGvDevice, aravis_sys::ArvGvDeviceClass, GvDeviceClass>) @extends Device;

	match fn {
		get_type => || aravis_sys::arv_gv_device_get_type(),
	}
}

impl GvDevice {
	/// ## `interface_address`
	/// address of the interface connected to the device
	/// ## `device_address`
	/// device address
	///
	/// # Returns
	///
	/// a newly created `Device` using GigE protocol
	pub fn new<P: IsA<gio::InetAddress>, Q: IsA<gio::InetAddress>>(
		interface_address: &P,
		device_address: &Q,
	) -> Result<GvDevice, glib::Error> {
		assert_initialized_main_thread!();
		unsafe {
			let mut error = ptr::null_mut();
			let ret = aravis_sys::arv_gv_device_new(
				interface_address.as_ref().to_glib_none().0,
				device_address.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(Device::from_glib_full(ret).unsafe_cast())
			} else {
				Err(from_glib_full(error))
			}
		}
	}
}

unsafe impl Send for GvDevice {}

pub const NONE_GV_DEVICE: Option<&GvDevice> = None;

/// Trait containing all `GvDevice` methods.
///
/// # Implementors
///
/// [`GvDevice`](struct.GvDevice.html)
pub trait GvDeviceExt: 'static {
	/// Automatically determine the biggest packet size that can be used data
	/// streaming, and set GevSCPSPacketSize value accordingly. This function relies
	/// on the GevSCPSFireTestPacket feature. If this feature is not available, the
	/// packet size will be set to a default value (1500 bytes).
	///
	/// # Returns
	///
	/// The packet size, in bytes.
	fn auto_packet_size(&self) -> Result<(), glib::Error>;

	///
	/// # Returns
	///
	/// the device IP address.
	fn get_device_address(&self) -> Option<gio::SocketAddress>;

	///
	/// # Returns
	///
	/// the device host interface IP address.
	fn get_interface_address(&self) -> Option<gio::SocketAddress>;

	fn get_packet_size(&self) -> Result<u32, glib::Error>;

	///
	/// # Returns
	///
	/// options for stream creation
	fn get_stream_options(&self) -> GvStreamOption;

	fn get_timestamp_tick_frequency(&self) -> Result<u64, glib::Error>;

	///
	/// # Returns
	///
	/// value indicating whether the ArvGvDevice has control access to the camera
	fn is_controller(&self) -> bool;

	fn set_packet_size(&self, packet_size: i32) -> Result<(), glib::Error>;

	/// Sets the option used during stream creation. It must be called before `Device::create_stream`.
	/// ## `options`
	/// options for stream creation
	fn set_stream_options(&self, options: GvStreamOption);
}

impl<O: IsA<GvDevice>> GvDeviceExt for O {
	fn auto_packet_size(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = ptr::null_mut();
			let _ = aravis_sys::arv_gv_device_auto_packet_size(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	fn get_device_address(&self) -> Option<gio::SocketAddress> {
		unsafe {
			from_glib_none(aravis_sys::arv_gv_device_get_device_address(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_interface_address(&self) -> Option<gio::SocketAddress> {
		unsafe {
			from_glib_none(aravis_sys::arv_gv_device_get_interface_address(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_packet_size(&self) -> Result<u32, glib::Error> {
		unsafe {
			let mut error = ptr::null_mut();
			let ret = aravis_sys::arv_gv_device_get_packet_size(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	fn get_stream_options(&self) -> GvStreamOption {
		unsafe {
			from_glib(aravis_sys::arv_gv_device_get_stream_options(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_timestamp_tick_frequency(&self) -> Result<u64, glib::Error> {
		unsafe {
			let mut error = ptr::null_mut();
			let ret = aravis_sys::arv_gv_device_get_timestamp_tick_frequency(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	fn is_controller(&self) -> bool {
		unsafe {
			from_glib(aravis_sys::arv_gv_device_is_controller(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn set_packet_size(&self, packet_size: i32) -> Result<(), glib::Error> {
		unsafe {
			let mut error = ptr::null_mut();
			let _ = aravis_sys::arv_gv_device_set_packet_size(
				self.as_ref().to_glib_none().0,
				packet_size,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	fn set_stream_options(&self, options: GvStreamOption) {
		unsafe {
			aravis_sys::arv_gv_device_set_stream_options(
				self.as_ref().to_glib_none().0,
				options.to_glib(),
			);
		}
	}
}

impl fmt::Display for GvDevice {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "GvDevice")
	}
}
