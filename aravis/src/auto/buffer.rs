// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use aravis_sys;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;
use std::mem;
use BufferPayloadType;
use BufferStatus;
use PixelFormat;

glib_wrapper! {
	pub struct Buffer(Object<aravis_sys::ArvBuffer, aravis_sys::ArvBufferClass, BufferClass>);

	match fn {
		get_type => || aravis_sys::arv_buffer_get_type(),
	}
}

impl Buffer {
	//pub fn new(size: usize, preallocated: /*Unimplemented*/Option<Fundamental: Pointer>) -> Buffer {
	//    unsafe { TODO: call aravis_sys:arv_buffer_new() }
	//}

	/// Creates a new buffer for the storage of the video stream images.
	/// The data space is allocated by this function, and will
	/// be freed when the buffer is destroyed.
	/// ## `size`
	/// payload size
	///
	/// # Returns
	///
	/// a new `Buffer` object
	pub fn new_allocate(size: usize) -> Buffer {
		assert_initialized_main_thread!();
		unsafe { from_glib_full(aravis_sys::arv_buffer_new_allocate(size)) }
	}
}

unsafe impl Send for Buffer {}

pub const NONE_BUFFER: Option<&Buffer> = None;

/// Trait containing all `Buffer` methods.
///
/// # Implementors
///
/// [`Buffer`](struct.Buffer.html)
pub trait BufferExt: 'static {
	/// Chunk data accessor.
	/// ## `chunk_id`
	/// chunk id
	/// ## `size`
	/// location to store chunk data size, or `None`
	///
	/// # Returns
	///
	/// a pointer to the chunk data.
	fn get_chunk_data(&self, chunk_id: u64) -> Vec<u8>;

	/// Gets the buffer frame id. For GigEVision devices, 0 is an invalid value.
	///
	/// # Returns
	///
	/// frame id, 0 on error.
	fn get_frame_id(&self) -> u64;

	/// Gets the image width. This function must only be called on buffer containing a `BufferPayloadType::Image` payload.
	///
	/// # Returns
	///
	/// image height, in pixels.
	fn get_image_height(&self) -> i32;

	/// Gets the image pixel format. This function must only be called on buffer containing a `BufferPayloadType::Image` payload.
	///
	/// # Returns
	///
	/// image pixel format.
	fn get_image_pixel_format(&self) -> PixelFormat;

	/// Gets the image region. This function must only be called on buffer containing a `BufferPayloadType::Image` payload.
	/// ## `x`
	/// image x offset placeholder
	/// ## `y`
	/// image y offset placeholder
	/// ## `width`
	/// image width placholder
	/// ## `height`
	/// image height placeholder
	fn get_image_region(&self) -> (i32, i32, i32, i32);

	/// Gets the image width. This function must only be called on buffer containing a `BufferPayloadType::Image` payload.
	///
	/// # Returns
	///
	/// image width, in pixels.
	fn get_image_width(&self) -> i32;

	/// Gets the image x offset. This function must only be called on buffer containing a `BufferPayloadType::Image` payload.
	///
	/// # Returns
	///
	/// image x offset, in pixels.
	fn get_image_x(&self) -> i32;

	/// Gets the image y offset. This function must only be called on buffer containing a `BufferPayloadType::Image` payload.
	///
	/// # Returns
	///
	/// image y offset, in pixels.
	fn get_image_y(&self) -> i32;

	/// Gets the buffer payload type.
	///
	/// # Returns
	///
	/// payload type.
	fn get_payload_type(&self) -> BufferPayloadType;

	/// Gets the buffer acquisition status.
	///
	/// # Returns
	///
	/// buffer acquisition status.
	fn get_status(&self) -> BufferStatus;

	/// Gets the system timestamp for when the frame was received. Expressed in
	/// nanoseconds.
	///
	/// # Returns
	///
	/// buffer system timestamp, in nanoseconds.
	fn get_system_timestamp(&self) -> u64;

	/// Gets the buffer camera timestamp, expressed as nanoseconds. Not all devices
	/// provide reliable timestamp, which means sometimes its better to rely on the
	/// buffer completion host local time, or to use
	/// `BufferExt::get_system_timestamp`.
	///
	/// # Returns
	///
	/// buffer timestamp, in nanoseconds.
	fn get_timestamp(&self) -> u64;

	//fn get_user_data(&self) -> /*Unimplemented*/Option<Fundamental: Pointer>;

	///
	/// # Returns
	///
	/// `true` if `self` has a payload type that contains chunk data.
	fn has_chunks(&self) -> bool;

	/// Sets the buffer frame id. For GigEVision devices, 0 is an invalid value.
	///
	/// Feature: `v0_8_3`
	///
	/// ## `frame_id`
	/// a `guint64`
	#[cfg(any(feature = "v0_8_3", feature = "dox"))]
	fn set_frame_id(&self, frame_id: u64);

	/// Sets the system timestamp for when the frame was received. Expressed in
	/// nanoseconds.
	/// ## `timestamp_ns`
	/// a timestamp, expressed as nanoseconds
	fn set_system_timestamp(&self, timestamp_ns: u64);

	/// Sets the buffer timestamp, which allows to override the timpestamp set by
	/// the camera, which in some case is incorrect.
	/// ## `timestamp_ns`
	/// a timestamp, expressed as nanoseconds
	fn set_timestamp(&self, timestamp_ns: u64);
}

impl<O: IsA<Buffer>> BufferExt for O {
	fn get_chunk_data(&self, chunk_id: u64) -> Vec<u8> {
		unsafe {
			let mut size = mem::MaybeUninit::uninit();
			let ret = FromGlibContainer::from_glib_none_num(
				aravis_sys::arv_buffer_get_chunk_data(
					self.as_ref().to_glib_none().0,
					chunk_id,
					size.as_mut_ptr(),
				),
				size.assume_init() as usize,
			);
			ret
		}
	}

	fn get_frame_id(&self) -> u64 {
		unsafe { aravis_sys::arv_buffer_get_frame_id(self.as_ref().to_glib_none().0) }
	}

	fn get_image_height(&self) -> i32 {
		unsafe { aravis_sys::arv_buffer_get_image_height(self.as_ref().to_glib_none().0) }
	}

	fn get_image_pixel_format(&self) -> PixelFormat {
		unsafe {
			from_glib(aravis_sys::arv_buffer_get_image_pixel_format(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_image_region(&self) -> (i32, i32, i32, i32) {
		unsafe {
			let mut x = mem::MaybeUninit::uninit();
			let mut y = mem::MaybeUninit::uninit();
			let mut width = mem::MaybeUninit::uninit();
			let mut height = mem::MaybeUninit::uninit();
			aravis_sys::arv_buffer_get_image_region(
				self.as_ref().to_glib_none().0,
				x.as_mut_ptr(),
				y.as_mut_ptr(),
				width.as_mut_ptr(),
				height.as_mut_ptr(),
			);
			let x = x.assume_init();
			let y = y.assume_init();
			let width = width.assume_init();
			let height = height.assume_init();
			(x, y, width, height)
		}
	}

	fn get_image_width(&self) -> i32 {
		unsafe { aravis_sys::arv_buffer_get_image_width(self.as_ref().to_glib_none().0) }
	}

	fn get_image_x(&self) -> i32 {
		unsafe { aravis_sys::arv_buffer_get_image_x(self.as_ref().to_glib_none().0) }
	}

	fn get_image_y(&self) -> i32 {
		unsafe { aravis_sys::arv_buffer_get_image_y(self.as_ref().to_glib_none().0) }
	}

	fn get_payload_type(&self) -> BufferPayloadType {
		unsafe {
			from_glib(aravis_sys::arv_buffer_get_payload_type(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_status(&self) -> BufferStatus {
		unsafe {
			from_glib(aravis_sys::arv_buffer_get_status(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_system_timestamp(&self) -> u64 {
		unsafe { aravis_sys::arv_buffer_get_system_timestamp(self.as_ref().to_glib_none().0) }
	}

	fn get_timestamp(&self) -> u64 {
		unsafe { aravis_sys::arv_buffer_get_timestamp(self.as_ref().to_glib_none().0) }
	}

	//fn get_user_data(&self) -> /*Unimplemented*/Option<Fundamental: Pointer> {
	//    unsafe { TODO: call aravis_sys:arv_buffer_get_user_data() }
	//}

	fn has_chunks(&self) -> bool {
		unsafe {
			from_glib(aravis_sys::arv_buffer_has_chunks(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[cfg(any(feature = "v0_8_3", feature = "dox"))]
	fn set_frame_id(&self, frame_id: u64) {
		unsafe {
			aravis_sys::arv_buffer_set_frame_id(self.as_ref().to_glib_none().0, frame_id);
		}
	}

	fn set_system_timestamp(&self, timestamp_ns: u64) {
		unsafe {
			aravis_sys::arv_buffer_set_system_timestamp(
				self.as_ref().to_glib_none().0,
				timestamp_ns,
			);
		}
	}

	fn set_timestamp(&self, timestamp_ns: u64) {
		unsafe {
			aravis_sys::arv_buffer_set_timestamp(self.as_ref().to_glib_none().0, timestamp_ns);
		}
	}
}

impl fmt::Display for Buffer {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "Buffer")
	}
}
