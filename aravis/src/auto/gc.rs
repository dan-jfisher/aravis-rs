// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

#[cfg(any(feature = "v0_8_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
use crate::AccessCheckPolicy;
use crate::Buffer;
use crate::Device;
use crate::DomDocument;
use crate::DomNode;
use crate::GcFeatureNode;
use crate::GcInvalidatorNode;
use crate::GcNode;
#[cfg(any(feature = "v0_8_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
use crate::RangeCheckPolicy;
use crate::RegisterCachePolicy;
use glib::object::Cast;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;

glib::wrapper! {
	#[doc(alias = "ArvGc")]
	pub struct Gc(Object<ffi::ArvGc, ffi::ArvGcClass>) @extends DomDocument, DomNode;

	match fn {
		type_ => || ffi::arv_gc_get_type(),
	}
}

impl Gc {
	//#[doc(alias = "arv_gc_new")]
	//pub fn new<P: IsA<Device>>(device: &P, xml: /*Unimplemented*/Option<Fundamental: Pointer>, size: usize) -> Gc {
	//    unsafe { TODO: call ffi:arv_gc_new() }
	//}

	#[doc(alias = "arv_gc_p_value_indexed_node_new")]
	pub fn p_value_indexed_node_new() -> Gc {
		assert_initialized_main_thread!();
		unsafe { GcNode::from_glib_full(ffi::arv_gc_p_value_indexed_node_new()).unsafe_cast() }
	}

	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_get_access_check_policy")]
	#[doc(alias = "get_access_check_policy")]
	pub fn access_check_policy(&self) -> AccessCheckPolicy {
		unsafe { from_glib(ffi::arv_gc_get_access_check_policy(self.to_glib_none().0)) }
	}

	/// Retrieves the binded buffer.
	///
	/// # Returns
	///
	/// a [`Buffer`][crate::Buffer].
	#[doc(alias = "arv_gc_get_buffer")]
	#[doc(alias = "get_buffer")]
	pub fn buffer(&self) -> Option<Buffer> {
		unsafe { from_glib_none(ffi::arv_gc_get_buffer(self.to_glib_none().0)) }
	}

	/// Retrieves the device handled by this genicam interface. The device is used for register access.
	///
	/// # Returns
	///
	/// a [`Device`][crate::Device].
	#[doc(alias = "arv_gc_get_device")]
	#[doc(alias = "get_device")]
	pub fn device(&self) -> Option<Device> {
		unsafe { from_glib_none(ffi::arv_gc_get_device(self.to_glib_none().0)) }
	}

	/// Retrieves a genicam node by name.
	/// ## `name`
	/// node name
	///
	/// # Returns
	///
	/// a [`GcNode`][crate::GcNode], null if not found.
	#[doc(alias = "arv_gc_get_node")]
	#[doc(alias = "get_node")]
	pub fn node(&self, name: &str) -> Option<GcNode> {
		unsafe {
			from_glib_none(ffi::arv_gc_get_node(
				self.to_glib_none().0,
				name.to_glib_none().0,
			))
		}
	}

	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_get_range_check_policy")]
	#[doc(alias = "get_range_check_policy")]
	pub fn range_check_policy(&self) -> RangeCheckPolicy {
		unsafe { from_glib(ffi::arv_gc_get_range_check_policy(self.to_glib_none().0)) }
	}

	#[doc(alias = "arv_gc_get_register_cache_policy")]
	#[doc(alias = "get_register_cache_policy")]
	pub fn register_cache_policy(&self) -> RegisterCachePolicy {
		unsafe { from_glib(ffi::arv_gc_get_register_cache_policy(self.to_glib_none().0)) }
	}

	#[doc(alias = "arv_gc_register_feature_node")]
	pub fn register_feature_node<P: IsA<GcFeatureNode>>(&self, node: &P) {
		unsafe {
			ffi::arv_gc_register_feature_node(
				self.to_glib_none().0,
				node.as_ref().to_glib_none().0,
			);
		}
	}

	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_set_access_check_policy")]
	pub fn set_access_check_policy(&self, policy: AccessCheckPolicy) {
		unsafe {
			ffi::arv_gc_set_access_check_policy(self.to_glib_none().0, policy.into_glib());
		}
	}

	#[doc(alias = "arv_gc_set_buffer")]
	pub fn set_buffer(&self, buffer: &Buffer) {
		unsafe {
			ffi::arv_gc_set_buffer(self.to_glib_none().0, buffer.to_glib_none().0);
		}
	}

	//#[doc(alias = "arv_gc_set_default_node_data")]
	//pub fn set_default_node_data(&self, node_name: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
	//    unsafe { TODO: call ffi:arv_gc_set_default_node_data() }
	//}

	#[cfg(any(feature = "v0_8_6", feature = "dox"))]
	#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_set_range_check_policy")]
	pub fn set_range_check_policy(&self, policy: RangeCheckPolicy) {
		unsafe {
			ffi::arv_gc_set_range_check_policy(self.to_glib_none().0, policy.into_glib());
		}
	}

	#[doc(alias = "arv_gc_set_register_cache_policy")]
	pub fn set_register_cache_policy(&self, policy: RegisterCachePolicy) {
		unsafe {
			ffi::arv_gc_set_register_cache_policy(self.to_glib_none().0, policy.into_glib());
		}
	}

	#[doc(alias = "arv_gc_invalidator_has_changed")]
	pub fn invalidator_has_changed(self_: &GcInvalidatorNode) -> bool {
		skip_assert_initialized!();
		unsafe { from_glib(ffi::arv_gc_invalidator_has_changed(self_.to_glib_none().0)) }
	}
}

unsafe impl Send for Gc {}

impl fmt::Display for Gc {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.write_str("Gc")
	}
}
