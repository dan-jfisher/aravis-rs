// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use aravis_sys;
use glib::object::Cast;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;
use Buffer;
use Device;
use DomDocument;
use DomNode;
use GcFeatureNode;
use GcInvalidatorNode;
use GcNode;
use RegisterCachePolicy;

glib_wrapper! {
	pub struct Gc(Object<aravis_sys::ArvGc, aravis_sys::ArvGcClass, GcClass>) @extends DomDocument, DomNode;

	match fn {
		get_type => || aravis_sys::arv_gc_get_type(),
	}
}

impl Gc {
	//pub fn new<P: IsA<Device>>(device: &P, xml: /*Unimplemented*/Option<Fundamental: Pointer>, size: usize) -> Gc {
	//    unsafe { TODO: call aravis_sys:arv_gc_new() }
	//}

	pub fn p_value_indexed_node_new() -> Gc {
		assert_initialized_main_thread!();
		unsafe {
			GcNode::from_glib_full(aravis_sys::arv_gc_p_value_indexed_node_new()).unsafe_cast()
		}
	}

	pub fn invalidator_has_changed<P: IsA<GcInvalidatorNode>>(self_: &P) -> bool {
		skip_assert_initialized!();
		unsafe {
			from_glib(aravis_sys::arv_gc_invalidator_has_changed(
				self_.as_ref().to_glib_none().0,
			))
		}
	}
}

unsafe impl Send for Gc {}

pub const NONE_GC: Option<&Gc> = None;

/// Trait containing all `Gc` methods.
///
/// # Implementors
///
/// [`Gc`](struct.Gc.html)
pub trait GcExt: 'static {
	/// Retrieves the binded buffer.
	///
	/// # Returns
	///
	/// a `Buffer`.
	fn get_buffer(&self) -> Option<Buffer>;

	/// Retrieves the device handled by this genicam interface. The device is used for register access.
	///
	/// # Returns
	///
	/// a `Device`.
	fn get_device(&self) -> Option<Device>;

	/// Retrieves a genicam node by name.
	/// ## `name`
	/// node name
	///
	/// # Returns
	///
	/// a `GcNode`, null if not found.
	fn get_node(&self, name: &str) -> Option<GcNode>;

	fn get_register_cache_policy(&self) -> RegisterCachePolicy;

	fn register_feature_node<P: IsA<GcFeatureNode>>(&self, node: &P);

	fn set_buffer<P: IsA<Buffer>>(&self, buffer: &P);

	//fn set_default_node_data(&self, node_name: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs);

	fn set_register_cache_policy(&self, policy: RegisterCachePolicy);
}

impl<O: IsA<Gc>> GcExt for O {
	fn get_buffer(&self) -> Option<Buffer> {
		unsafe {
			from_glib_none(aravis_sys::arv_gc_get_buffer(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_device(&self) -> Option<Device> {
		unsafe {
			from_glib_none(aravis_sys::arv_gc_get_device(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn get_node(&self, name: &str) -> Option<GcNode> {
		unsafe {
			from_glib_none(aravis_sys::arv_gc_get_node(
				self.as_ref().to_glib_none().0,
				name.to_glib_none().0,
			))
		}
	}

	fn get_register_cache_policy(&self) -> RegisterCachePolicy {
		unsafe {
			from_glib(aravis_sys::arv_gc_get_register_cache_policy(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	fn register_feature_node<P: IsA<GcFeatureNode>>(&self, node: &P) {
		unsafe {
			aravis_sys::arv_gc_register_feature_node(
				self.as_ref().to_glib_none().0,
				node.as_ref().to_glib_none().0,
			);
		}
	}

	fn set_buffer<P: IsA<Buffer>>(&self, buffer: &P) {
		unsafe {
			aravis_sys::arv_gc_set_buffer(
				self.as_ref().to_glib_none().0,
				buffer.as_ref().to_glib_none().0,
			);
		}
	}

	//fn set_default_node_data(&self, node_name: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
	//    unsafe { TODO: call aravis_sys:arv_gc_set_default_node_data() }
	//}

	fn set_register_cache_policy(&self, policy: RegisterCachePolicy) {
		unsafe {
			aravis_sys::arv_gc_set_register_cache_policy(
				self.as_ref().to_glib_none().0,
				policy.to_glib(),
			);
		}
	}
}

impl fmt::Display for Gc {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "Gc")
	}
}
